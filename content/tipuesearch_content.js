var tipuesearch = {"pages": [{'title': '各組期末報告說明', 'text': '', 'tags': '', 'url': '各組期末報告說明.html'}, {'title': '執行規劃', 'text': '', 'tags': '', 'url': '執行規劃.html'}, {'title': '手足球系統模擬', 'text': '專案成果摘要 \n 專案執行動機 \n 相關文獻探討 \n 專案執行成員 \n 執行使用套件 \n 專案執行過程規劃 \n 專案執行內容 \n 專案結論 \n', 'tags': '', 'url': '手足球系統模擬.html'}, {'title': '設計與繪圖', 'text': '', 'tags': '', 'url': '設計與繪圖.html'}, {'title': '零組件尺寸分析', 'text': '手足球系統的零組件尺寸分析 (可行性分析) \n 1.手足球場地(長:57.4in\xa0 寬:30in\xa0 總高:10.7in) \n \n 球門尺寸 \n \n', 'tags': '', 'url': '零組件尺寸分析.html'}, {'title': '參數設計與繪圖', 'text': '手足球系統的零組件參數設計與繪圖 (零組件初步設計繪圖) \n Onshape 零組件連結 \n', 'tags': '', 'url': '參數設計與繪圖.html'}, {'title': '細部設計與 BOM', 'text': '完成手足球零組件細部設計 (可參考 \xa0 https://youtu.be/PgnvZV5s13c \xa0 中各項設計), 並將設計 BOM (Bill of Materials) 納入 CMSimfly 網際內容管理系統. (系統 BOM 文件整理) \n 手足球 DIY 影片: \n 手足球零件格式說明 \n 手足球零件格式說明 \n 零件 BOM \n 手足球零組件材料表 (含零組件下載連結) \n 零件尺寸圖 \n 零件尺寸圖 \n 零件部分組裝圖 \n 零件部分組裝圖 \n 3D 零組件爆炸圖 \n 3D 零組件爆炸圖 \n 參考資料: \n https://www.matterhackers.com/articles/how-to-build-a-foosball-table \n https://www.matterhackers.com/store/digital-designs/foosball-table-parts \n', 'tags': '', 'url': '細部設計與 BOM.html'}, {'title': 'V-rep 動態模擬', 'text': '手足球系統中各球員擊球與操控桿移動旋轉的 V-rep 動態模擬 (系統功能模擬) \n 以文字及操作影片說明如何從 Onshape 設計繪製零組件後, 如何轉入 V-rep, 如何編寫程式, 如何進行各種功能測試, 最後完成手足球的 V-rep 動態模擬系統. \n', 'tags': '', 'url': 'V-rep 動態模擬.html'}, {'title': '送球機構設計與模擬', 'text': '手足球發球與進球後自動送球機構設計與 V-rep 動態模擬 (機構與傳動系統設計與模擬) \n 可採用螺旋機構或多連桿機構設計, 透過進球感測器感應後, 將儲存於螺桿上的球送回球檯. \n 以下為參考機構模擬影片: \n \n \n \n', 'tags': '', 'url': '送球機構設計與模擬.html'}, {'title': '系統功能展示', 'text': '手足球模擬系統功能展示 (模擬展示與說明影片) \n 以下提供所完成的 V-rep 系統模擬影片與相關檔案下載連結 \n \n 國立虎尾科技大學機械設計工程系 - 2019 Spring 第九週手足球運動模擬參考檔案 \n 足球員採用 Onshape 建立, 其他零組件採用 Solvespace 建立 \n 參考檔案位於:\xa0 https://github.com/mdecourse/cd2019/tree/gh-pages./../downloads/foosball_solvespace_vrep \n V-rep 場景檔案:\xa0 https://github.com/mdecourse/cd2019/blob/gh-pages./../downloads/foosball_solvespace_vrep/kmol_foosball_w9.ttt \n 以 V-rep 3.6.1 以上版本開啟檔案後執行, 鍵盤 a 與 d 鍵控制左右平移, w 與 s 鍵控制旋轉. \n \n \n', 'tags': '', 'url': '系統功能展示.html'}, {'title': '回擊系統模擬', 'text': "改寫code=python to lua並簡化 \n 優點: \n python : 可執行運算值較大的編譯 \n lua : Vrep內部沿用 , 延遲現象較少 \n 缺點: \n python : 會有爆ping問題導致延遲 \n lua : 太多運算時直接停止 \n \n \n function sysCall_init() \n    KickBallV = 10\n    R_KickBallVel = (math.pi/180)*KickBallV\n    B_KickBallVel = -(math.pi/180)*KickBallV\n    Sphere_handle=sim.getObjectHandle('Sphere')\n    BRod_handle=sim.getObjectHandle('BRod')\n    BRev_handle=sim.getObjectHandle('BRev')\n    BMo_handle=sim.getObjectHandle('BMo')\n    --\n    RRod_handle=sim.getObjectHandle('RRod')\n    RRev_handle=sim.getObjectHandle('RRev')\n    RMo_handle=sim.getObjectHandle('RMo')\nend\nfunction sysCall_actuation()\n    position_BR=sim.getObjectPosition(BRod_handle,-1)\n    position_S=sim.getObjectPosition(Sphere_handle,-1)\n    X =position_S[1] - position_BR[1]\n    Y =position_S[2] - position_BR[2]\n    if 1 then\n        if X <= 0.02 and Y <= 0 then\n            sim.setJointTargetVelocity(BRev_handle,B_KickBallVel)\n            sim.setJointTargetVelocity(BRev_handle,-1)\n        elseif X > 0.02 and Y <= 0 then\n            sim.setJointTargetVelocity(BRev_handle,B_KickBallVel)\n            sim.setJointTargetVelocity(BRev_handle,1)\n        elseif X <= 0.02 and Y > 0 then            \n            sim.setJointTargetVelocity(BRev_handle,R_KickBallVel)\n            sim.setJointTargetVelocity(BRev_handle,-1)        \n        elseif X > 0.02 and Y > 0 then            \n            sim.setJointTargetVelocity(BRev_handle,R_KickBallVel)    \n            sim.setJointTargetVelocity(BRev_handle,1)\n        end\n        YYYYY = Y*5\n        sim.setJointTargetVelocity(BMo_handle,YYYYY)\n    end\n---\n    position_RR=sim.getObjectPosition(RRod_handle,-1)\n    X =position_S[1] - position_RR[1]\n    Y =position_S[2] - position_RR[2]\n    if 1 then\n        if X <= 0.02 and Y <= 0 then\n            sim.setJointTargetVelocity(RRev_handle,B_KickBallVel)\n            sim.setJointTargetVelocity(RRev_handle,-1)\n        elseif X > 0.02 and Y <= 0 then\n            sim.setJointTargetVelocity(RRev_handle,B_KickBallVel)\n            sim.setJointTargetVelocity(RRev_handle,1)\n        elseif X <= 0.02 and Y > 0 then            \n            sim.setJointTargetVelocity(RRev_handle,R_KickBallVel)\n            sim.setJointTargetVelocity(RRev_handle,-1)        \n        elseif X > 0.02 and Y > 0 then            \n            sim.setJointTargetVelocity(RRev_handle,R_KickBallVel)    \n            sim.setJointTargetVelocity(RRev_handle,1)\n        end\n        YYYYY = Y*5\n        sim.setJointTargetVelocity(RMo_handle,YYYYY)\n    end\nend\n--by 40623130-- \n ttt檔 \n 原本要編寫切換鍵但於vrep中用io.clock等時間等待輸入雙命令時會出現運算值過大導致停止問題 , 所以先寫電腦打擊與跟蹤球 \n 原python code出處(by 40623128): https://mdekmol.github.io/cd2019a-task1-2019cda_t1_g3_1/content/%E6%89%8B%E8%B6%B3%E7%90%83%E6%89%8B%E6%8E%A7%E8%88%87%E9%9B%BB%E8%85%A6%E5%B0%8D%E6%89%93.html \n \n \n \n \n", 'tags': '', 'url': '回擊系統模擬.html'}, {'title': '結案報告', 'text': '', 'tags': '', 'url': '結案報告.html'}, {'title': '專案口頭簡報', 'text': '各組利用倉儲中的 Reveal.js 進行結案簡報 (結案口頭簡報) \n', 'tags': '', 'url': '專案口頭簡報.html'}, {'title': '專案報告書', 'text': '', 'tags': '', 'url': '專案報告書.html'}, {'title': '第十周前', 'text': '第十周前的網站內容 \n', 'tags': '', 'url': '第十周前.html'}, {'title': '簡介', 'text': '產品協同設計課程第二組 \n 倉儲位置 \n Blogger \n 評分表單 \n', 'tags': '', 'url': '簡介.html'}, {'title': '組員名單與網站', 'text': '周政叡-40423218   心得 \n 陳柏維-40423136\xa0心得 \n 吳隆廷-40623115   心得 \n 陳鉅忠-40623130 \xa0  心得 \n 蕭家翰-40623133   心得 \n 許高惟-40623139  \xa0 心得 \n 郭益綸- 40623142   心得 \n 林暉恩- 40623145   心得 \n \xa0  劉 奇\xa0 -40623146   心得 \n', 'tags': '', 'url': '組員名單與網站.html'}, {'title': 'Task-1', 'text': 'Web \n 取分項目 -工作分配表於3/18開會時分配 \n \n \n \n 第一項 \n 陳鉅忠 \n \n \n 第二項 \n 吳隆廷、郭益綸 \n \n \n 第三項 \n 許高惟、蕭家翰 、林暉恩 \n \n \n \n 若有不小心遺忘的請自行補齊 \n', 'tags': '', 'url': 'Task-1.html'}, {'title': '自定義隨身系統', 'text': '除了老師所提到的幾個重要的程式外，我們還加入老師提起的 Range_Software3 的分析軟體以及自己會用到的電路圖繪製軟體 Fritzing \n \n 都解壓縮完並設定好start批次檔時長這樣 \n \n Range_Software3 \n Github - 老師網誌 \n 是個結合了許多分析又可以繪圖的軟體，但對於操作完全不熟悉 \n \n Fritzing \n 官網 --- 下載 -Windows x64\xa0 Version------ 0.9.3b \xa0 was released on \xa0 June 2, 2016 . \n 我們會選擇此軟體的原因 \n 其一 : 電路學上課時老師推薦過 \n 其二 : 此程式可以編譯至可攜系統中 \n 其三 : 包含了許多大廠的板子且可用code編譯 \n 其四:可調成中文 \n \n 介紹影片 \n 周政叡-40423218 影片 \n 陳柏維-40423136  影片(雜音偏多 \n 許育誠-40423160\xa0 影片 \n 吳隆廷-40623115\xa0 影片 \n 陳鉅忠-40623130\xa0  影片 (聲音偏小 \n 蕭家翰-40623133   影片 \n 許高惟-40623139 \xa0 影片 \n 郭益綸- 40623142   影片 \n 林暉恩- 40623145   影片 \n \xa0 劉 奇\xa0 -40623146\xa0 影片 \n', 'tags': '', 'url': '自定義隨身系統.html'}, {'title': '隨機分組介面成品', 'text': '算是半成品的GUI介面 \xa0。 \xa0\xa0------>  成品 \n 說是半成品理由是 太多的理想面想法但能力不足... 我要把自己淘汰掉了。 \n 原本來想設計有存檔 、分行、直接編輯等功能 , 但真的沒那個能力可能要問問學長他們 , 之後還想轉成.exe檔 , 但現階段光下載 \xa0 pyinstaller 就一堆error啦...而且也要換成pyside2了可能就先放著去研究其他東西吧。 \n 還想用個GUI介面 , 是關於start.bat的 , 點擊後只跳出黑白窗各一個&一個點擊介面可以直接叫各程式的介面然後還能自己添加程式的功能 ( ( ( 科技進步出於人類的慾望--懶惰。 \n ----------------------------------------------------------- \n 利用大一學過的eric6設計生成的介面code \n \n 這段code位於Ui_task.py下方 , 主要是為了與下方程式task.py作聯結的code \n \n 按鈕主要的code設計 , 部分作小修改 \n PBsave鈕目前只有裝飾功能 , 尚未編譯 \n \n 這是執行後面介面樣子 \n \n 執行.txt檔後分出的組別排序 , 意想不到的是竟然可以讀取中文檔名的文件 \n \n Combine1.1&1.2 \n 測試結合  項目一 以及 項目二 \xa0, 其結果是只顯示出組長 \n \n 問題 :\xa0 \n eric6底下出現 " Qt: Untested Windows version 10.0 detected! " 此\xa0 連結 \xa0或許能改善 , 還在測試 \n 成品 \n 完成啦 - 69MB左右。 \n 完全沒想到轉成exe檔會大成這樣... \n 不過上星期到這次改版差了很多,不但整合了項目一與二 , 還修改了save as 按鈕(可用) , 還轉成了exe檔...很難想像因為一個enter換行導致一串的bug , 不過還是成功修改好了。 \n 改版Save as 按鈕成可用code , 並可直接存成.txt檔案 之後利用 pyinstaller(官方下載說明頁面) 測試看看能否轉py成exe檔案 , 但是明顯的出了幾個bug (1) cffi 過舊或是未安裝 --->需更新檔案---->pip cffi 就可以了\xa0 \xa0 \xa0( 沒記錯的話 (2)接下來是下方這個 , 黑窗表示 : 語法錯誤 \n \n 上網查後發現是下方這個.py檔的198行的空白行的問題... \n 刪除開白行即可 \n 之後就可正常用行囉 , pyinstaller會生成很多檔案而主要的exe檔在dist資料夾中 \n \n 之後到要轉檔的目錄位置打 pyinstaller -F -w -i 圖.ico 主程式.py -p 其餘程式\xa0-p 其餘程式\xa0\xa0-p 其餘程式\xa0\xa0-p 其餘程式\xa0 \n 以下為pyinstaller常用參數介紹 \n \n pyinstaller -h 來查看參數 \n -F : 打包成一個exe文件 \n –i 圖.ico : 更改ico圖示 \n -w : 使用視窗，無控制台 \n -c : 使用控制台，無視窗 \n -D : 創建一個目錄，包含exe以及其他一些依賴性文件 \n \n \n 完成品~ \n \n', 'tags': '', 'url': '隨機分組介面成品.html'}, {'title': '分組程式修正', 'text': '在利用亂數分組, 能否根據已經完成的主程式, 編寫一個網際程式或單機 PyQt5 程式, 讀進相關資料檔案後, 在瀏覽器或 PYQt5 程式中顯示出結果. \n import random \nfilename = \'cdbw3_student_list.txt\' \n# 每組人數 \nnum_in_one_group = 11 \n# 組序由 1 開始 \ngroup = 1 \n# 各班分組後所得數列 \nc2019 = [] \nwith open(filename) as f: \n    # 讀進全部檔案, 轉進數列, 並同時將各行的 \\n 去除 \n    read_data = f.read().splitlines()  \nprint("共有 " + str(len(read_data)) + " 位學員") \n# 利用 shuffle 將數列隨機弄亂 \nrandom.shuffle(read_data) \nfor i in range(len(read_data)): \n    # 利用整數相除的餘數進行分組 \n    if i%num_in_one_group == 0: \n        # 列出分隔符號 \n        print("-"*20) \n        print("group " + str(group) +":") \n        # 在分組區隔時重置各組學員數列 \n        group_list = [] \n        print() \n        # 同時列出與分隔標註對應 i 的數列內容 \n        print(read_data[i]) \n        group_list.append(read_data[i]) \n        group = group + 1 \n    else: \n        # 逐一列出同組的其他學員 \n        print(read_data[i]) \n        group_list.append(read_data[i]) \n    if i%num_in_one_group == 0: \n        c2019.append(group_list) \n# c2019 為該班分組後所得分組數列 \nprint(c2019) \n 原始程式只有將檔案cdbw3_student_list.txt讀進Python程式中做亂數分組 \n import random \nfilename = \'cdbw3_student_list.txt\' \n# 每組人數 \nnum_in_one_group = 8 \n# 組序由 1 開始 \ngroup = 1 \n# 各班分組後所得數列 \nc2019 = [] \nwith open(filename) as f: \n    # 讀進全部檔案, 轉進數列, 並同時將各行的 \\n 去除 \n    read_data = f.read().splitlines()  \nprint("共有 " + str(len(read_data)) + " 位學員") \n# 利用 shuffle 將數列隨機弄亂 \nrandom.shuffle(read_data) \nfor i in range(len(read_data)): \n    # 利用整數相除的餘數進行分組 \n    if i%num_in_one_group == 0: \n        # 列出分隔符號 \n        print("-"*20) \n        print("group " + str(group) +":") \n        # 在分組區隔時重置各組學員數列 \n        group_list = [] \n        print() \n        # 同時列出與分隔標註對應 i 的數列內容 \n        group_list.append(read_data[i]) \n        group = group + 1 \n        print("Leader:"+read_data[i]) \n    else: \n        print("Member:"+read_data[i]) \n    if i%num_in_one_group == 0: \n        c2019.append(group_list) \n# c2019 為該班分組後所得分組數列 \n \nprint("Group_leader"+str(c2019)) \n \n 在i 迴圈當中加入if i %num_in_one_group == 0: 檢驗ｉ除上組員數量是否=0 \n 假設等於0\xa0 \xa0 (整除無餘數) \n print("Leder:"+read_data[i])組長應是第一位選出來(read_data[i]) \n 假設不等於0\xa0 \xa0 (無整除) \n else: 其他的人為組員("Member:"+read_data[i]) \n 結果如下 \n \n 最下方為各組組長的顯示結果 \n', 'tags': '', 'url': '分組程式修正.html'}, {'title': 'ungit使用手冊', 'text': '老師的影片: \n \n 1.下載 ungit 與 node.js 程式碼 首先下載 \xa0 kmol_2019.7z , 接著再下載 \xa0 nodejs_with_ungit.7z , 兩者分別解開壓縮檔案, 然後將 nodejs 放入 kmol_2019 的 data 目錄中. \n 2.設定命令列搜尋路徑 \n 接下來設定啟動 start.bat 中的 ungit 命列列搜尋路徑: \n 新增 set path8=%Disk%:\\nodejs;%Disk%:\\nodejs\\appdata\\roaming\\npm; (抓取nodejs主程式路徑) \n path=%path%;%path1%;%path2%;%path3%;%path4%;%path5%;%path6%;%path7%;%Disk%:\\p37\\site-packages\\scipy\\extra_dll;%Disk%:\\scite\\bin; %path8%; \n \n 3.設定 USERPROFILE 環境變數 \n 讓 node.js 能夠使用 y:\\home 作為使用者目錄, 在 start.bat 中加入 set USERPROFILE=%Disk%:\\home \n \n 4. 以 SciTE 編輯器存入 Y:\\kungit.bat 批次檔案中 \n 為了對應 "C:\\Program Files (x86)", 針對目前所在的倉儲目錄, 以 Google Chrome 瀏覽器開啟 ungit 的網際倉儲連結. \n 新增批次檔 \n ungit --launchBrowser=0 --launchCommand "C:\\PROGRA~2\\Google\\Chrome\\Application\\chrome.exe\xa0 %%U" \n (指令內的PROGRA~2為Program file(x86)之縮寫，此外PROGRA~1為Program Flies縮寫) \n 為了跟ungit做一個區別批次檔名稱改成kungit並存在y:/底下 \n \n \n 5.開啟 start.bat， 輸入 kungit 後，會在瀏覽器中開啟ungit頁面 \n \n 6.利用ungit進行協同作業比原本使用cmd來的快速也較容易能判斷版本之間的改動 \n \n Title :可以輸入中文標題 \n Body :可以增加內容 讓其他協同組員知道這個版本增加什麼 \n Commit按鈕 : 可以不使用cmd指令就直接commit以節省時間 \n \n Push按鍵 : commit完成之後只要按版本旁邊的push就能將版本推到遠端 \n \n 每項commit在紅框內的視窗都有檔案的詳細資訊 \n 總結 : 這真的很方便， 唯二碰到的問題都是start的路徑沒有設定好 \n', 'tags': '', 'url': 'ungit使用手冊.html'}, {'title': '問題', 'text': '問題一 : Scite一直出現此錯誤且作者目前無解的問題 1.   2. \n \n 問題二 : Range 及 Fritzing 要存取檔時無法讀取Y槽，但是!!還是可以用? \n \n 問題三:ungit錯誤，結果是網路的問題! \n \n', 'tags': '', 'url': '問題.html'}, {'title': 'Task-2', 'text': 'Web \n', 'tags': '', 'url': 'Task-2.html'}, {'title': 'Vrep', 'text': 'BubbleRob \n 教學WEB \n \n 可作動 \n BubbleRob操作手冊 \n 1.建立BubbleRob本體 新增一個 Sphere ， X-size 為 0.2( 單位為m) 在 object common properties 下的 object special properties (特殊屬性參數)將 Collidable(可碰撞)、Measurable(可測量)、Renderable(可渲染)、Detectable(可檢測) 都打勾，將本體位置設定在Z軸(Along Z)0.02(必須確認本體是依照world去移動) 接著在選單雙擊Sphere將物件名稱改為BubbleRob就完成本體設定。 \n \n 2.建立Proxmity sensor(接近傳感器) 在選單中建立一個 Proximity sensor 且選為 Cone type (錐形) \n 將sensor利用旋轉功能在 Around Y及Z 輸入 90 位置為 X-coord 輸入 0.1 及 Z-coord 輸入 0.12 \n \n \n 接著設定sensor感應範圍，在選單點擊感測器符號開啟它的設定框，點擊 show volume\xa0 \n parameter (體積參數)開啟選單設定 Offset=0.005、Angle=30、Range=0.15 \n \n 點擊 Show detection parameters (檢測參數)，將 "Don\'t allow detections if distance smaller than" 選項取消打勾。 \n 將感測器名稱設定為 bubbleRob_sensingNose ，就完成感測器設定了。 \n 在 Scene hireachy (場景等級)將完成設定的sensor放在bubbleRob下 \n 最後將兩項物件 Edit->"Make last selected object parent" 連結成一個物件。 \n 3.建立bubbleRob的輪子 \n 建立一個 cylinder 尺寸為(0.08,0.08,0.02)，跟本體一樣將 object common properties 內的特殊屬性都打開，設定位置(0.05,0.1,0.04)和旋轉(-90,0,0)，此物件命名為 bubbleRob_leftWheel ，然後將完成的物件複製一份且將位置參數Y設定為-0.1，此物件命名為 bubbleRob_RightWheel \n 設定 joint (motor) Add->joint->Revolute (迴轉)建立一個軸，建立完成按住ctrl選擇剛剛的 bubbleRob_leftWheel 然後在 postion (位置)及 \xa0 orientation (方向)內選擇 apply to selection 來複製輪子的參數，這樣軸的位置就會跟左邊輪子一樣了。 點擊開啟軸參數的設定框，將 \xa0Show dynamic parameters (動態參數)內的 enable the motor 以及底下的 Lock motor when target velocity is zero 都打勾，完成左邊輪軸設定後，用同樣方式製作右輪軸。 \n 最後將輪子層級放置在輪軸底下，輪軸層級則置於本體下 \n \n 4.建立slider(滑塊) 開始模擬後發現機器人會向後翻轉，因為少了第三個接地點 建立一個圓形物件(設定0.05)，一樣打開所有特殊屬性，將此物件命名為 \xa0bubbleRob_slider ，在 shape dynamics properties 裡將物件設定為 無摩擦 。 \n 摩擦力相關的係數都調成0 \n \n 接著建立 Force sensor (力感測器)命名為 bubbleRob_connection ，將它往上提0.05 ，再跟剛剛的滑塊接合成一個物件，這個物件的位置設定X=(-0.07)，此物件的層級則放在bubbleRob底下，這樣就完成第三個接地點了，但是執行模擬後會發現滑塊會微微震動，那是因為滑塊跟本體互相碰撞了，為了避免這種狀況，開啟滑塊及本體的 shape dynamics properties 將 local respondable mask 分別設定為00001111及 11110000這樣兩個物件就不會互相碰撞了。 \n 滑塊設定 \n \n 本體設定 \n \n 5.增加穩定性(stability)及目標速度( Target velocity )測試 點擊dynamic對話框內的 M=M*2 選項三次將輪子以及第三個支點的重量變成8倍，接著在軸的dynamic對話框將 Target velocity 設至50後開始演算，會發現bubbleRob會穩定的直線前進最後掉出平台，然後再將速度重置為0，測試就完成了。 \n \n 6. collection object (物品集)及 Calculation module properties (計算模組) 在collection對話框內用 Add new collection ，新增的集合是空的，將列表上的bubbleRob選擇後點選Add加進collection，命名為  bubbleRob_collection  ，這樣bubbleRob底下的零件都包含集合裡。 在選單點選 Calculation module 在 distance (距離)下 Add new distance object ， 選擇剛剛新增的 bubbleRob_collection 及 all other measurable objects in the scene ， 命名為 bubbleRob_distance ，這個設定在之後會測量本體以及其他可碰撞物件之間的最小距離。 \n \n 7.Graph(圖表)設定 新增一個Graph命名為 bubbleRob_graph 在列表上放置於bubbleRob底下將graph位置設定在(0,0,0.005)開啟graph properties，將 Display XYZ-planes 選項取消打勾，接著 Add new data stream to record ，視窗上方 (Data stream type) 選擇 Object: absolute x-position 下方 (Object / item to record) 選擇 bubbleRob_graph ，在 Data stream recording list 會出現剛剛新增的設定，Y軸跟Z軸也用同樣方式做設定。 \n 為了能夠測量機器人跟環境之間的最小距離再新增一個設定上面選擇 Distance:segment length 下方選擇 bubbleRob_distance 。 \n \n 將XYZ軸及距離設定分別命名為 bubbleRob_xpos、bubbleRob_ypos、bubbleRob_zpos、 bubbleRob_obstacle_dist 。 \n \n 選擇bubbleRob_xpos在底下的 Time graph properties 將Visible取消掉，其他兩軸也用相同方式操作。 \n 接著在 Edit 3D curves 點選  Add new curve 設定如圖 \n \n Curve width (線寬)設定為4，然後改成 Relative to world ，完成後測試就會發現機器人的路徑會以線顯示在螢幕上。 \n 8.建立cylinder \n 增加數個(0.1,0.1,0.2)的cylinder包圍bubbleRob，將cylinder的特殊屬性參數全部打開，移動cylinder途中按著shift可以進行更細微的移動，按住ctrl則可以讓物件可以在正交方向移動。 \n 9.model設定 選擇bubbleRob後在 object common properties 內將 Object is model base 和 Object/model can transfer or accept DNA 都打勾，這樣bubbleRob邊界框就包含底下所有的物件在內了。 \n \n 接著將兩個joint、sensor跟graph都選起來然後將參數設定 ignored by model bounding box ，讓模型的邊界框略過sensor跟joint然後將joint跟sensor的camera visibility layer 2取消打勾改為打勾10，這樣在畫面上就不會看見軸跟sensor範圍了，最後將感測器、兩個輪子、支點、圖表的 Select base of model instead 都打勾，這項設定讓我們只能一次移動整個機器人而不是單個零件，能避免定位好的零件被移動。 \n \n (vrep版本3.6.1沒有 Don\'t show as inside model selection 按鈕) \n 10.感測器(vision sensor) 增加一個新的感測器，位置、角度跟BubbleRob\'s proximity sensor同樣，在畫面上點選增加 Perspective type 的sensor，然後放到proximity sensor底下，新的sensor設定如下 \n \n 接著點擊 Show filter dialog 開啟filter對話框，選擇 Edge detection on work image 然後按 Add ，新增的過濾組件要上移至第二層，移動完後點擊兩下剛剛設定的組件將 Threshold (閾值)設定為0.2，設定到這邊基本上就完成了。 \n \n 完成sensor設定後新增一個 floating view 然後在它上面右鍵選擇 (view->Associate view with selected vision sensor) 將視窗綁定到剛剛設定完的sensor上(操作中間要確保sensor是被選擇的狀況)，接著試著開始模擬，視窗上能夠看見目標就成功了。 \n \n 11.程式: 位於工具列的script功能可以編輯code \n \n 最後的步驟要將code放進完成的模型內，選擇bubbleRob點選( Add->Associated child script --> Non threaded ) \n \n 新增一個 non-threaded child script ，接著點選bubbleRob旁邊的圖示(如附圖) 就能打開script，將code複製在原本的code後面關掉視窗就完成了。 \n \n 需注意code內部\xa0 \n \n leftMotor=sim.getObjectHandle(" bubbleRob_leftMotor ") -- Handle of the left motor rightMotor=sim.getObjectHandle(" bubbleRob_rightMotor ") -- Handle of the right motor noseSensor=sim.getObjectHandle(" bubbleRob_sensingNose ") -- Handle of the proximity sensor \xa0 紅框內的名稱，如果大小寫或是名稱不同程式就沒辦法成功執行。 \n \n 成功的bubbleRob在模擬時會自動避開路徑上的物件，並且畫面會有能調節速度的面板。 \n', 'tags': '', 'url': 'Vrep.html'}, {'title': 'Vrep-2', 'text': "試著用鍵盤的前後左右測試robot -\xa0 Download \n \n 參考網址: http://www.forum.coppeliarobotics.com/viewtopic.php?t=1575&p=6085#p6065 \n \n week7測試物件 \n 測試用Vrep呼叫方向鍵的指令 \n \n \n (內建程式推不上去改用截圖放) \n ------------------------------------------------------------------------------------------------------------ \n 測試方向鍵於手足球的人偶自由度&code設定 :\xa0 \n RJ1 : 為人偶前後踢球的軸代稱\xa0 \\\xa0 RJ2 :\xa0 為控制人偶左右的桿子的軸代稱 \n 樹狀圖為gif中所表示 \n \n 下方為Lua code --->用於Vrep3.6.1版本中\xa0 \n function sysCall_init()  \n    right_left_handle= sim.getObjectHandle('RJ1') \n    up_down_handle= sim.getObjectHandle('RJ2') \n    MaxVel=5 \n    right_left_velocity=0 \n    up_down_velocity=0 \n    dVel=0.5; \n    sim.setJointTargetVelocity(right_left_handle,right_left_velocity) \n    sim.setJointTargetVelocity(up_down_handle,up_down_velocity) \nend \n \nfunction sysCall_actuation()  \n    message,auxiliaryData=sim.getSimulatorMessage() \n    while message~=-1 do \n        if (message==sim.message_keypress) then \n            if (auxiliaryData[1]==32) then \n                -- right key \n                right_left_velocity=0 \n                up_down_velocity=0 \n                sim.setJointForce(right_left_handle, 0) \n                sim.setJointForce(up_down_handle, 0) \n                break \n            else \n                sim.setJointForce(right_left_handle, 10000) \n                sim.setJointForce(up_down_handle, 10000) \n            end \n            if (auxiliaryData[1]==2007) then \n                -- left key \n                right_left_velocity=right_left_velocity+dVel*1.3 \n            end \n            if (auxiliaryData[1]==2008) then \n                -- right key \n                right_left_velocity=right_left_velocity-dVel*1.3 \n            end \n            if (auxiliaryData[1]==2009) then \n                -- up key \n                up_down_velocity=up_down_velocity+dVel/10 \n            end \n            if (auxiliaryData[1]==2010) then \n                -- down key \n                up_down_velocity=up_down_velocity-dVel/10 \n            end \n        end \n        message,auxiliaryData=sim.getSimulatorMessage() \n    end \n     \n    if right_left_velocity>MaxVel then \n        right_left_velocity=-5 \n    end \n    if right_left_velocity<-MaxVel then \n        right_left_velocity=5 \n    end \n     \n    if up_down_velocity>MaxVel then \n        up_down_velocity=0 \n    end \n    if up_down_velocity<-MaxVel then \n        up_down_velocity=0 \n    end \n     \n    sim.setJointTargetVelocity(right_left_handle,right_left_velocity) \n    sim.setJointTargetVelocity(up_down_handle,up_down_velocity) \n     \nend  \n 測試版本目前還未設定雙判定來改變控制的桿件(希望能行)&還有電腦的回擊也還沒寫入。 \n \n keyboard code 設定 {Unicode} :\xa0 \n http://www.runoob.com/try/try.php?filename=tryjsref_event_key_keycode \n \n week8測試物件 \n \n 嘗試將兩軸分開控制，由於我們是利用加速度來驗算所以在編寫code方面較為複雜，目標為利用鍵盤按鍵分別控制各軸，達成一次控制一軸且可切換之目標。 \n", 'tags': '', 'url': 'Vrep-2.html'}, {'title': 'Onshape', 'text': '圖檔位置 \n (1) 人形 : \n https://cad.onshape.com/documents/8c0be159fdc3c8e13fb701bf/w/d1d5f612592d280c6171a6b4/e/af8ccadea4c6f59a5ea6537c \n \n (2) 場地:\xa0 \n \xa0 https://cad.onshape.com/documents/0894dee7161cb625fbf66c24/w/dd82ba727b43d8551157d048/e/4e12526592dd2e271bca4ad7 \n \n 場地零件: \n \n \n \n \n 球: \n \n 場地增加: \n \n (3) 完成品:\xa0 \n \n 後來發現其實直接畫在一個零件裡就夠了,不然有些地方很難修改 \n 於是我們將場地精簡成這樣 \n \n 最終版本: \n \n', 'tags': '', 'url': 'Onshape.html'}, {'title': 'Extra-add', 'text': '擋球軌道 : \n https://cad.onshape.com/documents/4984320cf758c826a317595a/w/c314b8f3e5b6a9397411a635/e/56767dcb9a4bb6e5aa635f63 \n \n', 'tags': '', 'url': 'Extra-add.html'}, {'title': 'Final-handball', 'text': '尚未完成部分 :\xa0 \n \n \n \n 1 . 電腦操控一支桿件的回擊程式編譯 \n \n \n 2 .電腦操控多支桿件的回擊程式編譯 \n \n \n 3 . 玩家對桿件的切換程式編譯 \n \n \n 4 . 導球機構 \n \n \n 5 . \xa0 簡化 \n \n \n 6 . 計分設計 \n \n \n \n \n 不簡化的下場...死機十幾分鐘以上 \n 以下僅外觀 , 使用請小心 7z \n \n', 'tags': '', 'url': 'Final-handball.html'}, {'title': '期中報告', 'text': '嵌入期中報告影片 \n 周政叡-40423218 :\xa0 \n \n 陳柏維-40423136\xa0:\xa0 \n \n 吳隆廷-40623115\xa0:\xa0 \n \n 陳鉅忠-40623130 \xa0:\xa0 \n \n 蕭家翰-40623133 \xa0:\xa0 \n \n 許高惟-40623139 \xa0:\xa0 \n \n 郭益綸- 40623142 \xa0:\xa0 \n \n 林暉恩- 40623145 \xa0:\xa0 \n \n \xa0  劉 奇\xa0 -40623146\xa0:\xa0 \n', 'tags': '', 'url': '期中報告.html'}, {'title': 'Virtualbox虛擬主機網路設定', 'text': 'Step1：前往 雲端載點 將檔案UB1804下載下來。 \n Step2：開啟Oracle VM VirtualBox Manager。 \n Step3：點擊右方視窗中的"NEW"按鈕來新增虛擬主機(名稱可隨意)，按下NEXT。 \n Step3：將Memory size調到4GB，按下NEXT。 \n Step4：將Hard disk選擇Use an existing virtual hard disk file(選項第三個)。 \n Step5：選擇檔案右方按鈕尋找"ub1804"檔案按下確定。 \n Step6：回到主畫面，點擊剛剛建立的虛擬主機ub1804，點擊右方視窗中的Setting前往設定。 \n Step7：左方選單中選擇Network，在右方視窗的Attached to選單中選擇Bridged Adapter(當使用者需要利用虛擬主機建立與 Host 位階相同的網路模式時，可以將虛擬主機的網卡設訂為 Bridged Adapter.)，確認後按下OK。 \n Step8：回到主畫面，啟動剛剛設定好的檔案，在右方視窗按下Start。 \n Step9：輸入帳號密碼(帳號：kmol2019密碼：kmol2019) \n Step10：可以輸入 ifconfig 來查看IP。 \n Step11：輸入 cd /etc/netplan 按下Enter後，輸入1s -1按下Enter。 \n Step12：輸入 sudo vi 50-clould-init.yaml按下Enter。 \n Step13：輸入密碼kmol2019，前往設定。 \n (上下左右為 K J H L) \n 步驟14：dhcp4：false  \u3000\u3000\u3000\u3000地址：192.168.56.2/24  gateway4  \u3000\u3000\u3000\u3000：192.168.56.1 \n Step15：編輯完成按下Ctrl+C退出，然後輸入sudo netplan apply同意設定。 \n Step16：輸入ifconfig 檢查ip。 \n Step17：輸入sudo survice cmsimfly restart重新啟動。 \n 影片如下： \n \n', 'tags': '', 'url': 'Virtualbox虛擬主機網路設定.html'}, {'title': '換行code 改寫', 'text': '圖中寫到 : 因html中可能還有中文字元在尚未喘成unf8時會出現語法錯誤 , 所以轉成unf8換完行後再轉回原本的字元 \n 如右邊所呈現有成功換行 \n \n code: \n # encoding=utf8\nimport re\n\nrep = {"h1": "h2", "h2": "h3", "h3": "h4"} # define desired replacements here\n\n# use these three lines to do the replacement\nrep = dict((re.escape(k), v) for k, v in rep.items())\npattern = re.compile("|".join(rep.keys()))\n\n#text = pattern.sub(lambda m: rep[re.escape(m.group(0))], text),editing by 40623130\n\nresult = pattern.sub(lambda m: rep[re.escape(m.group(0))],"""\n\n""")\n\nprint(result) \n \n', 'tags': '', 'url': '換行code 改寫.html'}, {'title': '圖形簡化', 'text': '球桿簡化 \n \n', 'tags': '', 'url': '圖形簡化.html'}, {'title': '第十二周', 'text': "----暫時放著---- \n 改寫code=python to lua並簡化 \n 優點: \n python : 可執行運算值較大的編譯 \n lua : Vrep內部沿用 , 延遲現象較少 \n 缺點: \n python : 會有爆ping問題導致延遲 \n lua : 太多運算時直接停止 \n \n \n function sysCall_init() \n    KickBallV = 10\n    R_KickBallVel = (math.pi/180)*KickBallV\n    B_KickBallVel = -(math.pi/180)*KickBallV\n    Sphere_handle=sim.getObjectHandle('Sphere')\n    BRod_handle=sim.getObjectHandle('BRod')\n    BRev_handle=sim.getObjectHandle('BRev')\n    BMo_handle=sim.getObjectHandle('BMo')\n    --\n    RRod_handle=sim.getObjectHandle('RRod')\n    RRev_handle=sim.getObjectHandle('RRev')\n    RMo_handle=sim.getObjectHandle('RMo')\nend\nfunction sysCall_actuation()\n    position_BR=sim.getObjectPosition(BRod_handle,-1)\n    position_S=sim.getObjectPosition(Sphere_handle,-1)\n    X =position_S[1] - position_BR[1]\n    Y =position_S[2] - position_BR[2]\n    if 1 then\n        if X <= 0.02 and Y <= 0 then\n            sim.setJointTargetVelocity(BRev_handle,B_KickBallVel)\n            sim.setJointTargetVelocity(BRev_handle,-1)\n        elseif X > 0.02 and Y <= 0 then\n            sim.setJointTargetVelocity(BRev_handle,B_KickBallVel)\n            sim.setJointTargetVelocity(BRev_handle,1)\n        elseif X <= 0.02 and Y > 0 then            \n            sim.setJointTargetVelocity(BRev_handle,R_KickBallVel)\n            sim.setJointTargetVelocity(BRev_handle,-1)        \n        elseif X > 0.02 and Y > 0 then            \n            sim.setJointTargetVelocity(BRev_handle,R_KickBallVel)    \n            sim.setJointTargetVelocity(BRev_handle,1)\n        end\n        YYYYY = Y*5\n        sim.setJointTargetVelocity(BMo_handle,YYYYY)\n    end\n---\n    position_RR=sim.getObjectPosition(RRod_handle,-1)\n    X =position_S[1] - position_RR[1]\n    Y =position_S[2] - position_RR[2]\n    if 1 then\n        if X <= 0.02 and Y <= 0 then\n            sim.setJointTargetVelocity(RRev_handle,B_KickBallVel)\n            sim.setJointTargetVelocity(RRev_handle,-1)\n        elseif X > 0.02 and Y <= 0 then\n            sim.setJointTargetVelocity(RRev_handle,B_KickBallVel)\n            sim.setJointTargetVelocity(RRev_handle,1)\n        elseif X <= 0.02 and Y > 0 then            \n            sim.setJointTargetVelocity(RRev_handle,R_KickBallVel)\n            sim.setJointTargetVelocity(RRev_handle,-1)        \n        elseif X > 0.02 and Y > 0 then            \n            sim.setJointTargetVelocity(RRev_handle,R_KickBallVel)    \n            sim.setJointTargetVelocity(RRev_handle,1)\n        end\n        YYYYY = Y*5\n        sim.setJointTargetVelocity(RMo_handle,YYYYY)\n    end\nend\n--by 40623130-- \n ttt檔 \n 原本要編寫切換鍵但於vrep中用io.clock等時間等待輸入雙命令時會出現運算值過大導致停止問題 , 所以先寫電腦打擊與跟蹤球 \n 原python code出處(by 40623128): https://mdekmol.github.io/cd2019a-task1-2019cda_t1_g3_1/content/%E6%89%8B%E8%B6%B3%E7%90%83%E6%89%8B%E6%8E%A7%E8%88%87%E9%9B%BB%E8%85%A6%E5%B0%8D%E6%89%93.html \n", 'tags': '', 'url': '第十二周.html'}, {'title': '第十三周', 'text': '', 'tags': '', 'url': '第十三周.html'}, {'title': 'V-rep簡化', 'text': '簡化目的是要把繁瑣的圖形切割，變成比較簡單的圖形切割，程式在模擬的時候將會變得順暢。 \n \n 利用V-rep裡面的 Manual mesh division(手動分割網格)來合併圖塊。 \n \n 圖形簡化後變成許多圖塊。 \n \n 完成之後合併圖塊。 \n \n 檔案位址：\u3000 ./../downloads/40623115(group).7z \n 各零件的圖形簡化如上面步驟： \n 人形-分割 \n \n 人形-簡化 \n \n 桿件-分割 \n \n 桿件-簡化 \n \n 檔案位址： ./../downloads/人形.7z \n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0\xa0 ./../downloads/桿件.7z \n 球台兩側簡化 \n \n 問題：簡化後的圖形無法合成成一整體?! \n 球台修正 \n \n \n 檔案位址： ./../downloads/球台兩側-簡化.7z \n \n \n 參考資料： https://www.cnblogs.com/21207-iHome/p/6704194.html \n', 'tags': '', 'url': 'V-rep簡化.html'}, {'title': '第十四周-簡化', 'text': '檔案:第一版  簡化版本1 \n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0第二版  簡化版本2 \n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0第三版 簡化版本3 \n 完成品 \n \n 球員分布 \n \n 組合中發現球員與軸向偏差，在組合時修正 \n \n 側視圖 \n \n 因組員反應高度無法擊球，故在高度上進行調整 \n \n 桿件隱藏 \n \n 實際作動物件及外觀在組合時需注意位置及方向，作動的簡化物件在圖上隱藏。 \n 5/27更新 \n 第一版本 \n \n 預設的第一個版本 \n 第二版本 \n \n 經小組員討論，將多餘的空格消除，同時也是球員往下修正之版本 \n 第三版本 \n \n 測試後證實，原球軌入球口會卡住球，故第三版本將側面孔完全消除。 \n 第四版本(目前測試版本) \n \n \n 將原先設計的突起及角落圓角消除，讓模擬更順暢。 \n', 'tags': '', 'url': '第十四周-簡化.html'}, {'title': '編輯報告書', 'text': '下載： https://drive.google.com/file/d/1lH3J-EETOpNruAz86Mi8A4PcKkgJOsh2/view \n 解壓縮完裡面有兩個資料夾 \n \xa0pandoc-2.4-windows-x86_64 和\xa0miktex_portable \n 用SciTE 開啟start.bat \n 在path=的最後方新增： \n %Disk%:\\pandoc-2.4-windows-x86_64;%Disk%:\\miktex_portable\\texmfs\\install\\miktex\\bin; \n \n 接著在cmd (小黑窗) 中輸入： \n python -m pip install pandoc-fignos pandoc-tablenos pandoc-eqnos \n 安裝完成後重新啟動可攜系統即可 \n 參考內容： https://mdecp2018.github.io/finalproject-bgx/content/Kmol-editor.html \n 參考作法： https://mdekmol.github.io/cd2019a-task1-2019cda_t1_g3_1/content/%E5%A6%82%E4%BD%95%E9%96%8B%E5%A7%8B%E7%B7%A8%E8%BC%AF%E5%A0%B1%E5%91%8A%E6%9B%B8.html \n \n 各組完成 html 與 pdf 格式之手足球專案結案報告 (文字結案報告書)', 'tags': '', 'url': '編輯報告書.html'}, {'title': '第十五周', 'text': '完成手足球程式編譯，剩下場地修改，由於組員軌道製作時間過長所以先用程式寫回球。 \n 當中有很多版本，從{多桿件設定與測試} →{多桿件回位設定與測試}→{導入電腦對打&第二桿件電腦判斷添加}→{加入電腦對打&第二及三桿件電腦對打code}→{第四桿件電腦回擊設定}→{球重生&左下計分}，沒意外下個版本就可以結束了。((全寫在lua中 \n 影片是照順序放der \n 檔案也是 1 → 2 → 3 → 4 → 5 → 6\xa0 → 7 \n \n \n \n \n 目前最新版本 \n \n ↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓ \n 目前最新版本 \n \n ↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓ \n function sysCall_init()\n    Ball=sim.getObjectHandle(\'ball\')\n    --player--\n    Slide_rail= sim.getObjectHandle(\'R1\')\n    Roller= sim.getObjectHandle(\'RR1\')\n    Slide_rail2= sim.getObjectHandle(\'R2\')\n    Roller2= sim.getObjectHandle(\'RR2\')\n    Slide_rail3= sim.getObjectHandle(\'R3\')\n    Roller3= sim.getObjectHandle(\'RR3\')\n    Slide_rail4= sim.getObjectHandle(\'R4\')\n    Roller4= sim.getObjectHandle(\'RR4\')\n    Slide_rail_v=0\n    Roller_v=0\n    Roller_v2=0\n    Roller_v3=0\n    Roller_v4=0\n    dVel=0.5\n    --computer--\n    Body=sim.getObjectHandle(\'LSO1\')\n    Body2=sim.getObjectHandle(\'LSO2\')\n    Body3=sim.getObjectHandle(\'LSO3\')\n    Body4=sim.getObjectHandle(\'LSO4\')\n--  test=sim.getObjectHandle(\'LS3_P1\')\n    LR1=sim.getObjectHandle(\'LR1\')  \n    LR2=sim.getObjectHandle(\'LR2\')\n    LR3=sim.getObjectHandle(\'LL3\')\n    LR4=sim.getObjectHandle(\'LR4\')\n    L1=sim.getObjectHandle(\'L1\')\n    L2=sim.getObjectHandle(\'L2\')\n    L3=sim.getObjectHandle(\'L3\')\n    L4=sim.getObjectHandle(\'L4\')\n    --goal--\n    Player_G = 0\n    Computer_G = 0\nend\n\nfunction sysCall_actuation()\n    --player--\n    A= sim.getObjectHandle(\'RS1_PO1\') --auto_return--1\n    PA= sim.getObjectPosition(A,-1)\n    if PA[1] >= -0.712 then\n        Roller_v = Roller_v + dVel*3\n    end\n    B= sim.getObjectHandle(\'RS2_PO1\') --auto_return--2\n    PB= sim.getObjectPosition(B,-1)\n    if PB[1] >= -0.531 then\n        Roller_v2 = Roller_v2 + dVel*3\n    end\n    C= sim.getObjectHandle(\'RS4_PO2\') --auto_return--3\n    PC= sim.getObjectPosition(C,-1)\n    if PC[1] >= -0.197 then\n        Roller_v3=Roller_v3 + dVel*5\n    end\n    D= sim.getObjectHandle(\'RS3_PO1\') --auto_return--4\n    PD= sim.getObjectPosition(D,-1)\n    if PD[1] >= 0.137 then\n        Roller_v4=Roller_v4 + dVel*5\n    end\n\n    message,auxiliaryData=sim.getSimulatorMessage()\n    while message~=-1 do\n        if (message==sim.message_keypress) then   \n            if (auxiliaryData[1]==32) then   --"space"--restart\n              sim.setObjectPosition(Ball,-1,{-0.1429, -0.1334, 0.5})\n            end\n            if (auxiliaryData[1]==122) then  --"z"--goalkeeper\n               Roller_v = Roller_v - dVel*50\n               if (Roller_v > 0) then\n                  Roller_v = 0\n               end\n            end\n            if (auxiliaryData[1]==120) then   --"x"--2\n               Roller_v2 = Roller_v2 - dVel*30\n               if (Roller_v2 > 0) then\n                  Roller_v2 = 0\n               end\n            end\n            if (auxiliaryData[1]==99) then  --"c"--3\n               Roller_v3 = Roller_v3 - dVel*30\n               if (Roller_v3 > 0) then\n                  Roller_v3 = 0\n               end\n            end\n            if (auxiliaryData[1]==118) then  --"v"--4\n               Roller_v4 = Roller_v4 - dVel*30\n               if (Roller_v4 > 0) then\n                  Roller_v4 = 0\n               end\n            end\n            if (auxiliaryData[1]==2008) then --"down"--return_player\n                Roller_v = Roller_v + dVel*20\n                Roller_v2 = Roller_v2 + dVel*20\n                Roller_v3 = Roller_v3 + dVel*20\n                Roller_v4 = Roller_v4 + dVel*20\n               if (Roller_v < 0) then\n                  Roller_v = 0\n               end\n               if (Roller_v2 < 0) then\n                  Roller_v2 = 0\n               end\n               if (Roller_v3 < 0) then\n                  Roller_v3 = 0\n               end\n               if (Roller_v4 < 0) then\n                  Roller_v4 = 0\n               end\n            end\n            if (auxiliaryData[1]==2009) then --"right"\n               Slide_rail_v = Slide_rail_v + dVel/5\n               if (Slide_rail_v < 0) then\n                  Slide_rail_v = 0\n               end\n            end\n            if (auxiliaryData[1]==2010) then --"left"\n                Slide_rail_v = Slide_rail_v - dVel/5\n                if (Slide_rail_v > 0) then\n                  Slide_rail_v = 0\n                end\n            end\n        end\n        message,auxiliaryData=sim.getSimulatorMessage()\n    end\n    Slide_rail_v2 = Slide_rail_v/1.3\n    Slide_rail_v3 = Slide_rail_v/1.5\n    Slide_rail_v4 = Slide_rail_v/1.4\n    sim.setJointTargetVelocity(Slide_rail,Slide_rail_v)\n    sim.setJointTargetVelocity(Roller,Roller_v)\n    sim.setJointTargetVelocity(Slide_rail2,Slide_rail_v2)\n    sim.setJointTargetVelocity(Roller2,Roller_v2)\n    sim.setJointTargetVelocity(Slide_rail3,Slide_rail_v3)\n    sim.setJointTargetVelocity(Roller3,Roller_v4)\n    sim.setJointTargetVelocity(Slide_rail4,Slide_rail_v4)\n    sim.setJointTargetVelocity(Roller4,Roller_v3)\n    --computer--\n    Body_s = sim.getObjectPosition(Body,-1)\n    Ball_s = sim.getObjectPosition(Ball,-1)\n    X = Body_s[1] - Ball_s[1]\n    Y = Body_s[2] - Ball_s[2]\n    if 1 then  --C_goalkeeper\n        if X <= 0.02 then\n            sim.setJointTargetVelocity(LR1,-5)\n            sim.setJointTargetVelocity(L1,0)\n        elseif X > 0.02 or X <= 0.01 then\n            sim.setJointTargetVelocity(LR1,5)\n            YYYYY = Y*7\n            sim.setJointTargetVelocity(L1,YYYYY)\n        end\n--[[    if X <= 0.02 and Y <= 0 then   --old_version\n            sim.setJointTargetVelocity(LR1,-5)\n        elseif X > 0.02 and Y <= 0 then\n            sim.setJointTargetVelocity(LR1,2)\n        elseif X <= 0.02 and Y > 0 then          40623130  \n            sim.setJointTargetVelocity(LR1,-5)        \n        elseif X > 0.02 and Y > 0 then                \n            sim.setJointTargetVelocity(LR1,2)\n        end]]\n    end\n\n    Body_s2 = sim.getObjectPosition(Body2,-1)\n    X2_1 = Body_s2[1] - Ball_s[1]\n    Y2_1 = Body_s2[2] - Ball_s[2] - 0.15\n    Y2_2 = Body_s2[2] - Ball_s[2] + 0.15\n    if X2_1 >= 0.02 then --C_second--\n        if Ball_s[2] <= -0.133 then\n            C_K_B_X2()\n        Y2_1 = Y2_1*5\n        sim.setJointTargetVelocity(L2,Y2_1)\n        elseif Ball_s[2] > -0.133 then\n            C_K_B_X2()\n        Y2_2 = Y2_2*5\n        sim.setJointTargetVelocity(L2,Y2_2)\n        end\n    end\n\n    Body_s4 = sim.getObjectPosition(Body4,-1)\n    X4_1 = Body_s4[1] - Ball_s[1]\n    Y4_1 = Body_s4[2] - Ball_s[2] - 0.15\n    Y4_2 = Body_s4[2] - Ball_s[2] + 0.15\n    if X4_1 >= 0.02 then --C_third--\n        if Ball_s[2] <= -0.133 then\n            C_K_B_X4()\n        Y4_1 = Y4_1*3\n        sim.setJointTargetVelocity(L4,Y4_1)\n        elseif Ball_s[2] > -0.133 then\n            C_K_B_X4()\n        Y4_2 = Y4_2*3\n        sim.setJointTargetVelocity(L4,Y4_2)\n        end\n    end\n--[[\n    test_s = sim.getObjectPosition(test,-1)\n    M =  test_s[2]- Ball_s[2]\n    print(M)\n--]]\n    Body_s3 = sim.getObjectPosition(Body3,-1)\n    X3_1 = Body_s3[1] - Ball_s[1]\n    Y3_1 = Body_s3[2] - Ball_s[2]\n    Y3_2 = Body_s3[2] - Ball_s[2] +0.2487\n    Y3_3 = Body_s3[2] - Ball_s[2] -0.2487\n    if X3_1 >= 0.02 then --C_fourth--\n        if Ball_s[2] < -0.0028 and Ball_s[2] >= -0.2487 then\n            C_K_B_X3()\n        Y3_1 = Y3_1*2\n        sim.setJointTargetVelocity(L3,Y3_1)\n        elseif Ball_s[2] >= -0.0028 then\n            C_K_B_X3()\n        Y3_2 = Y3_2*2\n        sim.setJointTargetVelocity(L3,Y3_2)\n        elseif Ball_s[2] < -0.2487 then\n            C_K_B_X3()\n        Y3_3 = Y3_3*2\n        sim.setJointTargetVelocity(L3,Y3_3)\n        end\n    end\n    --reborn_ball & count goal--\n    if Ball_s[1] < -0.85 then\n        Player_G = Player_G + 1\n    end    \n    if Ball_s[1] >= 0.61 then\n        Computer_G = Computer_G+1\n    end\n    if Ball_s[1] < -0.85 or Ball_s[1] >= 0.61 then\n        sim.setObjectPosition(Ball,-1,{-0.1429, -0.1334, 0.5})\n        print[[Player:Computer]]\n        print(\'      \'..Computer_G..\'     \'..Player_G)\n    end\nend\nfunction C_K_B_X2() --C_second_kick--\n    if X2_1 < 0.03 then\n    sim.setJointTargetVelocity(LR2,-5)\n    elseif X2_1 > 0.03 then\n    sim.setJointTargetVelocity(LR2,5)\n    end\nend\nfunction C_K_B_X3() --C_third_kcik--\n    if X3_1 < 0.03 then\n    sim.setJointTargetVelocity(LR3,-5)\n    elseif X3_1 > 0.03 then\n    sim.setJointTargetVelocity(LR3,5)\n    end\nend\nfunction C_K_B_X4() --C_fourth_kick--\n    if X4_1 < 0.03 then\n    sim.setJointTargetVelocity(LR4,-5)\n    elseif X4_1 > 0.03 then\n    sim.setJointTargetVelocity(LR4,5)\n    end\nend', 'tags': '', 'url': '第十五周.html'}]};