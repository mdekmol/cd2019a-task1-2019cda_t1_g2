var tipuesearch = {"pages": [{'title': '簡介', 'text': '產品協同設計課程第二組 \n 倉儲位置 \n Blogger \n 評分表單 \n', 'tags': '', 'url': '簡介.html'}, {'title': '組員名單與網站', 'text': '組長: \n 陳鉅忠-40623130 \xa0  心得 \n 組員: \n 周政叡-40423218   心得 \n 陳柏維-40423136\xa0心得 \n 吳隆廷-40623115   心得 \n 蕭家翰-40623133   心得 \n 許高惟-40623139  \xa0 心得 \n 郭益綸- 40623142   心得 \n 林暉恩- 40623145   心得 \n 劉 奇 -40623146   心得 \n', 'tags': '', 'url': '組員名單與網站.html'}, {'title': '執行規劃', 'text': '', 'tags': '', 'url': '執行規劃.html'}, {'title': '手足球系統模擬', 'text': '執行規劃為每週安排任務，計畫通常趕不上變化，而變化通常趕不上長官的一句話: \n W11 - 開會討論工作分配以及之後各週目標。 \n W12 - 利用Onshape 設計並將各零件及場地繪製完成並導出、簡化導出圖檔。 \n W13 - 利用Onshape 設計並將各零件及場地繪製完成並導出、利用Lua測試並完成手足球1對1回擊。 \n W14 - 於Vrep設定回球機構、利用Lua測試並完成手足球玩家對電腦。 \n W15 - 結合全部物件測試&修改 \n W16 - 整理並開始編輯個人網站&小組網站&PDF&影片。 \n W17 - 在課堂上進行分組報告。 \n', 'tags': '', 'url': '手足球系統模擬.html'}, {'title': '設計與繪圖', 'text': '', 'tags': '', 'url': '設計與繪圖.html'}, {'title': '零組件尺寸分析', 'text': '手足球系統的零組件尺寸分析 (可行性分析) \n 1.手足球場地(長:57.4in\xa0 寬:30in\xa0 總高:10.7in) \n \n 原先球門牆壁厚度為0.7in \n \n \n 後來在模擬時發現球門前的球員動作距離有限,球容易卡在死角,最後決定將球門牆壁加厚 \n 球門尺寸 \n \n \n 球員總高4.3in以及跟竿子結合的洞(直徑)為0.562in \n \n 竿子直徑為0.562in \n 原本的竿子有給限制頭尾，但後來發現在模擬時會有一些小問題，所以決定去除 \n \n \n 〈軌道詳細設計〉 \n 設計初步草圖 \n \n 寬度設計1.5因需比球體半徑大一些 \n \n 螺旋線高度為4，為緩衝設計加大 \n \n 中間段使用掃略出圖形 \n 完成軌道及線架構 \n \n 軌道最終版 \n 由於我們的擊球系統過於強大，會讓球從舊版軌道直接飛出去，所以才把軌道上面封起來，變成最終版 \n \n 〈 集球門〉第三版 \n 初步草圖\xa0 \xa0 進球口 \n \n 出球口 \n \n \n 使用疊成拉伸把外圍先做出來，原本是想說看可不可以直接把孔一起用好，但Onshape似乎沒辦法做到，只好把孔另外再做出來 \n \n \n 疊成拉伸 \n \n 利用草圖四的邊線來繪製通道，並伸長2英吋 \n \n \n 在使用右側視圖畫出與上一個通道一樣的圖，伸長2英吋並選擇對稱 \n \n \n 而直向通道與橫向通道，因為有縫隙會造成簡化的難度，所以就伸長到下一個面 \n \n 因為伸長的關係所以要再開一個洞 \n \n 做這個斜坡是因為怕球撞到通道會反彈而不會滾去擊球裝置的位置，也可以讓球被擊出後能順利的進入軌道 \n \n \n 延伸的通道是為了擊球裝置的最大伸長路徑 \n \n 〈擊球檯 〉 \n 長為2.362英吋，寬為1.575英吋，向上伸長0.5英吋 \n \n 邊框向內偏移0.079英吋，向上伸長1英吋 \n \n \n 要先開孔 \n \n \n 在內部畫一個比孔小一點的圓為擊球桿 \n \n \n 1.3X1.3的正方形，伸長0.079英吋 \n \n \n 在尾端畫一個阻擋物以防擊球桿整支飛出去 \n \n \n \n \n 〈組合圖 〉 \n 這是最一開始的初步組合圖， \n 場地四周內側設計有圓角、場地上有突出障礙物以及回球機構 \n 設計理念: \n 1.圓角:以防球模擬時跑到角落就不會動了 \n 2.障礙物:多點障礙物，增加遊戲難度 \n 3.回球機構:任何一方得分後，球會自動回到場上 \n \n 但由於在模擬及簡化時有問題 \n 就砍掉之前的場地設計及距離 \n 因為過多增加系統負擔的圖形，只會拖慢模擬速度 \n 而回球機構我們設計了一個擊球系統 \n 擊球系統:任何一方得分後，球進入軌道，會由擊球機構把球擊出並沿著軌道回到被得分那一方上 \n', 'tags': '', 'url': '零組件尺寸分析.html'}, {'title': '參數設計與繪圖', 'text': '手足球系統的零組件參數設計與繪圖 (零組件初步設計繪圖) \n Onshape 零組件連結 \n 【機構設計】 \n 〈初始設計〉 \n 初始設計挑出了選多方案，如: \n 1.桿件推送 \n 2.螺旋尺上推 \n 3.打擊軌道 \n \n 最後挑選打擊裝置搭配配斜面軌道的方式將球送出。 \n 因只需一次做動就可完成目標。 \n \n 〈軌道設計〉 \n \n 最初設計是想將兩條軌道集合一束，用一次打擊就可， \n 但後來發現會有收束誤差與繪製上的困難，後來還是改 \n 為左右各開一條軌道，後來還是改為左右各開一條軌道 \n 並各自擁有一打擊裝置。 \n 最後採用複斜面旋轉軌道，將球送至最高點後，再使用斜面將球滾落。 \n \n 〈打擊機構設計〉 \n \n 打擊機構非常直覺，就是使用一個帶緣圓棒將球打擊出去， \n 並外掛置打擊區旁，作為球之動力。 \n \n 〈 集球門 〉 \n 原先的設計，發現組裝後門框的高度沒有高於球門，怕會出現卡球的可能所以要重新畫 \n \n \n \n 第二版\xa0 \n \n 在畫的時候發現球檯沒有高度，而假如球快速的撞擊檔板可能會造成球直接反彈並有可能回到場地內，就把球檯加高3英吋，在檔板的部分畫成密閉式以防球會跑出去 \n \n 而在這裡加裝這支橫桿是因為在舊版的球門框有高低的落差，如果不加這支橫桿球在進入擊球門前會被凹槽卡住，因為這個原因所以在新版就把高低落差的問題給解決所以在新版就沒有這支橫桿。 \n \n \n 一開始畫通道的時候，想說話圓弧型的比較好滾動，但在簡化方面就比較困難，所以在第三版畫的時候就把它改成方形的。 \n \n \n \n 〈 軌道 〉初版 \n 因為當時還不確定球的大小，就先設計較大的尺寸，以利後續挑整 \n \n \xa0用螺旋線做去軌道的路線 \n \n 用掃掠將軌道做出 \n \n 最後的下銳 \n \n 不過因為螺旋半徑不夠大、下銳角太大、整體上升不足......等問題做了第二代 \n \n', 'tags': '', 'url': '參數設計與繪圖.html'}, {'title': '細部設計與 BOM', 'text': '各零件圖 BOM \n 球場 \n 工程圖連結 \n \n 球員 \n 工程圖連結 \n \n 軌道 \n 工程圖連結 \n \n 導球球門 \n 工程圖連結 \n \n 擊球系統 \n 工程圖連結 \n \n 場地組合 \n 工程圖連結 \n \n 組合圖 BOM \n 工程圖連結 \n \n', 'tags': '', 'url': '細部設計與 BOM.html'}, {'title': 'V-rep 動態模擬', 'text': '手足球系統中各球員擊球與操控桿移動旋轉的 V-rep 動態模擬 (系統功能模擬) \n 以文字及操作影片說明如何從 Onshape 設計繪製零組件後, 如何轉入 V-rep, 如何編寫程式, 如何進行各種功能測試, 最後完成手足球的 V-rep 動態模擬系統. \n', 'tags': '', 'url': 'V-rep 動態模擬.html'}, {'title': '送球機構設計與模擬', 'text': '由於當初設計不量沒考慮周到導致距離太遠及斜度太過另外球含有很0.75的彈性係數，這導致球根本上不去有時還飛出軌道...我想到的解決方法是加上蓋子以及在球於軌道中時寫個判斷式讓球傳送到離洞口較近的下坡，想不到球一開始就過不了洞，之後又寫了個讓球能滾出去的code，這是偷吃步的方法也是利用程式輔助機構的方法，雖然很不真實但確實可行。 \n \n 下方這段是個簡單的判別式:當球的X>0.905同時Y<-0.069又同時Z<0.036時，推球的機構往前push，第二段也是同理只是相反邊，而第三段則是當球的Z方向數值大於0.036時兩者回到初始位置。 \n function reborn_ball_count_goal()\n\n    if Ball_s[1] > 0.905 and Ball_s[2] < -0.069 and Ball_s[3] < 0.036 then\n        sim.setJointTargetVelocity(Push_1,1)\n    end\n\n    if Ball_s[1] < -1.15 and Ball_s[2] < -0.123 and Ball_s[3] < 0.036 then\n        sim.setJointTargetVelocity(Push_2,-1)\n    end\n\n    if Ball_s[3] > 0.036 then\n        sim.setJointTargetVelocity(Push_1,-1)\n        sim.setJointTargetVelocity(Push_2,1)\n    end\n\nend \n 下方的這幾行也是相同道理，當球的XYZ同時滿足條件時(也是擊球後，球滾到一半時的位置)被傳送到另一位置，在從另一位置傳送到另一位置。 \n function reborn_ball_count_goal() \n    if Ball_s[1] < -1.156 and Ball_s[2] > 0.163 and Ball_s[3] > 0.058 then\n    sim.setObjectPosition(Ball,-1,{-0.20361, 0.2739, 0.15735})\n    end\n    if Ball_s[1] < -0.20361 and Ball_s[2] > 0.2740 and Ball_s[3] > 0.15735 then\n    sim.setObjectPosition(Ball,-1,{-0.2049, 0.23, 0.1482})\n    end\n    if Ball_s[1] > 0.9056 and Ball_s[2] <  -0.4247 and Ball_s[3] > 0.0592 then\n    sim.setObjectPosition(Ball,-1,{-0.043425,  -0.60401, 0.15735})\n    end\n    if Ball_s[1] > -0.04753 and Ball_s[2] <  -0.5240 and Ball_s[3] > 0.15735 then\n    sim.setObjectPosition(Ball,-1,{-0.03667,  -0.48443, 0.1482})\n    end\nend \n \n 檔案: https://github.com/mdecadp2018/site-40623130/blob/gh-pages/v-rep/robot/C_Goal_4.3.ttt(((( 檔案與球檯結合了 \n \n \n', 'tags': '', 'url': '送球機構設計與模擬.html'}, {'title': '系統功能展示', 'text': '\n 這裡紀載了全部的手足球版本以及詳細歷程 \n 人機對決 \n 最終版本的\'玩家與電腦\'對打，完整code \n 操作說明:方向鍵的左右下按鍵 、z、x、c、v分別按順序從z的守門員到v的最前排、R鍵用來讓球回位至正中央(怕卡bug) \n \n function sysCall_init()\n    Ball=sim.getObjectHandle(\'ball\')\n    --player--\n    Slide_rail= sim.getObjectHandle(\'R1\')\n    Roller= sim.getObjectHandle(\'RR1\')\n    Slide_rail2= sim.getObjectHandle(\'R2\')\n    Roller2= sim.getObjectHandle(\'RR2\')\n    Slide_rail3= sim.getObjectHandle(\'R3\')\n    Roller3= sim.getObjectHandle(\'RR3\')\n    Slide_rail4= sim.getObjectHandle(\'R4\')\n    Roller4= sim.getObjectHandle(\'RR4\')\n    Slide_rail_v=0\n    Roller_v=0\n    Roller_v2=0\n    Roller_v3=0\n    Roller_v4=0\n    dVel=0.5\n    --computer--\n    Body=sim.getObjectHandle(\'LSO1\')\n    Body2=sim.getObjectHandle(\'LSO2\')\n    Body3=sim.getObjectHandle(\'LSO3\')\n    Body4=sim.getObjectHandle(\'LSO4\')\n    LR1=sim.getObjectHandle(\'LR1\')  \n    LR2=sim.getObjectHandle(\'LR2\')\n    LR3=sim.getObjectHandle(\'LL3\')\n    LR4=sim.getObjectHandle(\'LR4\')\n    L1=sim.getObjectHandle(\'L1\')\n    L2=sim.getObjectHandle(\'L2\')\n    L3=sim.getObjectHandle(\'L3\')\n    L4=sim.getObjectHandle(\'L4\')\n    --goal--\n    Player_G = 0\n    Computer_G = 0\n    --reball--\n    Push_1=sim.getObjectHandle(\'Push_1\')\n    Push_2=sim.getObjectHandle(\'Push_2\')\nend\n\nfunction sysCall_actuation()\n    --player--\n    A= sim.getObjectHandle(\'RS1_PO1\') --auto_return--1\n    PA= sim.getObjectPosition(A,-1)\n    if PA[1] >= -0.712 then\n        Roller_v = Roller_v + dVel*2.5\n    end\n    B= sim.getObjectHandle(\'RS2_PO1\') --auto_return--2\n    PB= sim.getObjectPosition(B,-1)\n    if PB[1] >= -0.531 then\n        Roller_v2 = Roller_v2 + dVel*5\n    end\n    C= sim.getObjectHandle(\'RS4_PO2\') --auto_return--3\n    PC= sim.getObjectPosition(C,-1)\n    if PC[1] >= -0.197 then\n        Roller_v3=Roller_v3 + dVel*5\n    end\n    D= sim.getObjectHandle(\'RS3_PO1\') --auto_return--4\n    PD= sim.getObjectPosition(D,-1)\n    if PD[1] >= 0.137 then\n        Roller_v4=Roller_v4 + dVel*5\n    end\n\n    message,auxiliaryData=sim.getSimulatorMessage()\n    while message~=-1 do\n        if (message==sim.message_keypress) then   \n            if (auxiliaryData[1]==114) then   --"r"--restart\n              sim.setObjectPosition(Ball,-1,{-0.15, -0.1334, 0.5})\n            end\n            if (auxiliaryData[1]==122) then  --"z"--goalkeeper\n               Roller_v = Roller_v - dVel*60\n               if (Roller_v > 0) then\n                  Roller_v = 0\n               end\n            end\n            if (auxiliaryData[1]==120) then   --"x"--2\n               Roller_v2 = Roller_v2 - dVel*15\n               if (Roller_v2 > 0) then\n                  Roller_v2 = 0\n               end\n            end\n            if (auxiliaryData[1]==99) then  --"c"--3\n               Roller_v3 = Roller_v3 - dVel*15\n               if (Roller_v3 > 0) then\n                  Roller_v3 = 0\n               end\n            end\n            if (auxiliaryData[1]==118) then  --"v"--4\n               Roller_v4 = Roller_v4 - dVel*15\n               if (Roller_v4 > 0) then\n                  Roller_v4 = 0\n               end\n            end\n            if (auxiliaryData[1]==2008) then --"down"--return_player\n                Roller_v = Roller_v + dVel*20\n                Roller_v2 = Roller_v2 + dVel*20\n                Roller_v3 = Roller_v3 + dVel*20\n                Roller_v4 = Roller_v4 + dVel*20\n               if (Roller_v < 0) then\n                  Roller_v = 0\n               end\n               if (Roller_v2 < 0) then\n                  Roller_v2 = 0\n               end\n               if (Roller_v3 < 0) then\n                  Roller_v3 = 0\n               end\n               if (Roller_v4 < 0) then\n                  Roller_v4 = 0\n               end\n            end\n            if (auxiliaryData[1]==2009) then --"right"\n               Slide_rail_v = Slide_rail_v + dVel/5\n               if (Slide_rail_v < 0) then\n                  Slide_rail_v = 0\n               end\n            end\n            if (auxiliaryData[1]==2010) then --"left"\n                Slide_rail_v = Slide_rail_v - dVel/5\n                if (Slide_rail_v > 0) then\n                  Slide_rail_v = 0\n                end\n            end\n        end\n        message,auxiliaryData=sim.getSimulatorMessage()\n    end\n    Slide_rail_v2 = Slide_rail_v/1.3\n    Slide_rail_v3 = Slide_rail_v/1.5\n    Slide_rail_v4 = Slide_rail_v/1.4\n    sim.setJointTargetVelocity(Slide_rail,Slide_rail_v)\n    sim.setJointTargetVelocity(Roller,Roller_v)\n    sim.setJointTargetVelocity(Slide_rail2,Slide_rail_v2)\n    sim.setJointTargetVelocity(Roller2,Roller_v2)\n    sim.setJointTargetVelocity(Slide_rail3,Slide_rail_v3)\n    sim.setJointTargetVelocity(Roller3,Roller_v4)\n    sim.setJointTargetVelocity(Slide_rail4,Slide_rail_v4)\n    sim.setJointTargetVelocity(Roller4,Roller_v3)\n    --computer--\n    Body_s = sim.getObjectPosition(Body,-1)\n    Ball_s = sim.getObjectPosition(Ball,-1)\n    X = Body_s[1] - Ball_s[1]\n    Y = Body_s[2] - Ball_s[2]\n    if 1 then  --C_goalkeeper\n        if X <= 0.02 then\n            sim.setJointTargetVelocity(LR1,-5)\n            sim.setJointTargetVelocity(L1,0)\n        elseif X > 0.02 or X <= 0.01 then\n            sim.setJointTargetVelocity(LR1,5)\n            YYYYY = Y*7\n            sim.setJointTargetVelocity(L1,YYYYY)\n        end\n    end\n\n    Body_s2 = sim.getObjectPosition(Body2,-1)\n    X2_1 = Body_s2[1] - Ball_s[1]\n    Y2_1 = Body_s2[2] - Ball_s[2] - 0.15\n    Y2_2 = Body_s2[2] - Ball_s[2] + 0.15\n    if X2_1 >= 0.01 then --C_second--\n        if Ball_s[2] <= -0.133 then\n            C_K_B_X2()\n        Y2_1 = Y2_1*5\n        sim.setJointTargetVelocity(L2,Y2_1)\n        elseif Ball_s[2] > -0.133 then\n            C_K_B_X2()\n        Y2_2 = Y2_2*5\n        sim.setJointTargetVelocity(L2,Y2_2)\n        end\n    end\n\n    Body_s4 = sim.getObjectPosition(Body4,-1)\n    X4_1 = Body_s4[1] - Ball_s[1]\n    Y4_1 = Body_s4[2] - Ball_s[2] - 0.15\n    Y4_2 = Body_s4[2] - Ball_s[2] + 0.15\n    if X4_1 >= 0.01 then --C_third--\n        if Ball_s[2] <= -0.133 then\n            C_K_B_X4()\n        Y4_1 = Y4_1*3\n        sim.setJointTargetVelocity(L4,Y4_1)\n        elseif Ball_s[2] > -0.133 then\n            C_K_B_X4()\n        Y4_2 = Y4_2*3\n        sim.setJointTargetVelocity(L4,Y4_2)\n        end\n    end\n\n    Body_s3 = sim.getObjectPosition(Body3,-1)\n    X3_1 = Body_s3[1] - Ball_s[1]\n    Y3_1 = Body_s3[2] - Ball_s[2]\n    Y3_2 = Body_s3[2] - Ball_s[2] +0.2487\n    Y3_3 = Body_s3[2] - Ball_s[2] -0.2487\n    if X3_1 >= 0.01 then --C_fourth--\n        if Ball_s[2] < -0.0028 and Ball_s[2] >= -0.2487 then\n            C_K_B_X3()\n        Y3_1 = Y3_1*2.5\n        sim.setJointTargetVelocity(L3,Y3_1)\n        elseif Ball_s[2] >= -0.0028 then\n            C_K_B_X3()\n        Y3_2 = Y3_2*2.5\n        sim.setJointTargetVelocity(L3,Y3_2)\n        elseif Ball_s[2] < -0.2487 then\n            C_K_B_X3()\n        Y3_3 = Y3_3*2.5\n        sim.setJointTargetVelocity(L3,Y3_3)\n        end\n    end\n    --reborn_ball & count goal--\n    reborn_ball_count_goal()\nend\nfunction C_K_B_X2() --C_second_kick--\n    if X2_1 < 0.06 then\n    sim.setJointTargetVelocity(LR2,-5)\n    elseif X2_1 > 0.03 then\n    sim.setJointTargetVelocity(LR2,5)\n    end\nend\nfunction C_K_B_X3() --C_third_kcik--\n    if X3_1 < 0.06 then\n    sim.setJointTargetVelocity(LR3,-5)\n    elseif X3_1 > 0.03 then\n    sim.setJointTargetVelocity(LR3,5)\n    end\nend\nfunction C_K_B_X4() --C_fourth_kick--\n    if X4_1 < 0.06 then\n    sim.setJointTargetVelocity(LR4,-5)\n    elseif X4_1 > 0.03 then\n    sim.setJointTargetVelocity(LR4,5)\n    end\nend\nfunction reborn_ball_count_goal()\n    if Ball_s[1] < -0.85 and Ball_s[1] > -0.87 then\n        Player_G = Player_G + 1\n    end    \n    if Ball_s[1] > 0.61 and Ball_s[1] < 0.62 then\n        Computer_G = Computer_G + 1\n    end\n    if Ball_s[1] < -0.85 or Ball_s[1] > 0.61 then\n        print[[Player : Computer]]\n        print(\'      \'..Computer_G..\'     \'..Player_G)\n    end\n\n    if Ball_s[1] > 0.905 and Ball_s[2] < -0.069 and Ball_s[3] < 0.036 then\n        sim.setJointTargetVelocity(Push_1,1)\n    elseif Ball_s[3] > 0.036 then\n        sim.setJointTargetVelocity(Push_1,-1)\n    end\n    if Ball_s[1] < -1.15 and Ball_s[2] < -0.123 and Ball_s[3] < 0.036 then\n        sim.setJointTargetVelocity(Push_2,-1)\n    elseif Ball_s[3] > 0.036 then\n        sim.setJointTargetVelocity(Push_2,1)\n    end\n\n    if Ball_s[1] < -1.156 and Ball_s[2] > 0.163 and Ball_s[3] > 0.058 then\n    sim.setObjectPosition(Ball,-1,{-0.20361, 0.2739, 0.15735})\n    end\n    if Ball_s[1] < -0.20361 and Ball_s[2] > 0.2740 and Ball_s[3] > 0.15735 then\n    sim.setObjectPosition(Ball,-1,{-0.2049, 0.23, 0.1482})\n    end\n    if Ball_s[1] > 0.9056 and Ball_s[2] <  -0.4247 and Ball_s[3] > 0.0592 then\n    sim.setObjectPosition(Ball,-1,{-0.043425,  -0.60401, 0.15735})\n    end\n    if Ball_s[1] > -0.04753 and Ball_s[2] <  -0.5240 and Ball_s[3] > 0.15735 then\n    sim.setObjectPosition(Ball,-1,{-0.03667,  -0.48443, 0.1482})\n    end\nend \n \n 檔案: https://github.com/mdecadp2018/site-40623130/blob/gh-pages/v-rep/robot/FinalVersion.ttt \n 機² 對決 \n 寫完人機對打後，花了不到1小時寫完電腦對電腦的版本 \n \n function sysCall_init()\n    Ball=sim.getObjectHandle(\'ball\')\n    --computer--\n    Body=sim.getObjectHandle(\'LSO1\')\n    Body2=sim.getObjectHandle(\'LSO2\')\n    Body3=sim.getObjectHandle(\'LSO3\')\n    Body4=sim.getObjectHandle(\'LSO4\')\n    LR1=sim.getObjectHandle(\'LR1\')  \n    LR2=sim.getObjectHandle(\'LR2\')\n    LR3=sim.getObjectHandle(\'LL3\')\n    LR4=sim.getObjectHandle(\'LR4\')\n    L1=sim.getObjectHandle(\'L1\')\n    L2=sim.getObjectHandle(\'L2\')\n    L3=sim.getObjectHandle(\'L3\')\n    L4=sim.getObjectHandle(\'L4\')\n    --computer2--\n    Body_2=sim.getObjectHandle(\'RSO1\')\n    Body2_2=sim.getObjectHandle(\'RSO2\')\n    Body3_2=sim.getObjectHandle(\'RSO3\')\n    Body4_2=sim.getObjectHandle(\'RSO4\')\n    RR1=sim.getObjectHandle(\'RR1\')  \n    RR2=sim.getObjectHandle(\'RR2\')\n    RR3=sim.getObjectHandle(\'RR3\')\n    RR4=sim.getObjectHandle(\'RR4\')\n    R1=sim.getObjectHandle(\'R1\')\n    R2=sim.getObjectHandle(\'R2\')\n    R3=sim.getObjectHandle(\'R3\')\n    R4=sim.getObjectHandle(\'R4\')\n    --goal--\n    Player_G = 0\n    Computer_G = 0\n    --reball--\n    Push_1=sim.getObjectHandle(\'Push_1\')\n    Push_2=sim.getObjectHandle(\'Push_2\')\nend\n \nfunction sysCall_actuation()\n    message,auxiliaryData=sim.getSimulatorMessage()\n    while message~=-1 do\n        if (message==sim.message_keypress) then  \n            if (auxiliaryData[1]==114) then   --"r"--restart\n              sim.setObjectPosition(Ball,-1,{-0.15, -0.1334, 0.5})\n            end\n        end\n        message,auxiliaryData=sim.getSimulatorMessage()\n    end\n    --computer--\n    Body_s = sim.getObjectPosition(Body,-1)\n    Ball_s = sim.getObjectPosition(Ball,-1)\n    X = Body_s[1] - Ball_s[1]\n    Y = Body_s[2] - Ball_s[2]\n    if 1 then  --C_goalkeeper\n        if X <= 0.02 then\n            sim.setJointTargetVelocity(LR1,-5)\n            sim.setJointTargetVelocity(L1,0)\n        elseif X > 0.02 or X <= 0.01 then\n            sim.setJointTargetVelocity(LR1,5)\n            YYYYY = Y*7\n            sim.setJointTargetVelocity(L1,YYYYY)\n        end\n    end\n \n    Body_s2 = sim.getObjectPosition(Body2,-1)\n    X2_1 = Body_s2[1] - Ball_s[1]\n    Y2_1 = Body_s2[2] - Ball_s[2] - 0.15\n    Y2_2 = Body_s2[2] - Ball_s[2] + 0.15\n    if X2_1 >= 0.01 then --C_second--\n        if Ball_s[2] <= -0.133 then\n            C_K_B_X2()\n        Y2_1 = Y2_1*5\n        sim.setJointTargetVelocity(L2,Y2_1)\n        elseif Ball_s[2] > -0.133 then\n            C_K_B_X2()\n        Y2_2 = Y2_2*5\n        sim.setJointTargetVelocity(L2,Y2_2)\n        end\n    end\n \n    Body_s4 = sim.getObjectPosition(Body4,-1)\n    X4_1 = Body_s4[1] - Ball_s[1]\n    Y4_1 = Body_s4[2] - Ball_s[2] - 0.15\n    Y4_2 = Body_s4[2] - Ball_s[2] + 0.15\n    if X4_1 >= 0.01 then --C_third--\n        if Ball_s[2] <= -0.133 then\n            C_K_B_X4()\n        Y4_1 = Y4_1*3\n        sim.setJointTargetVelocity(L4,Y4_1)\n        elseif Ball_s[2] > -0.133 then\n            C_K_B_X4()\n        Y4_2 = Y4_2*3\n        sim.setJointTargetVelocity(L4,Y4_2)\n        end\n    end\n \n    Body_s3 = sim.getObjectPosition(Body3,-1)\n    X3_1 = Body_s3[1] - Ball_s[1]\n    Y3_1 = Body_s3[2] - Ball_s[2]\n    Y3_2 = Body_s3[2] - Ball_s[2] +0.2487\n    Y3_3 = Body_s3[2] - Ball_s[2] -0.2487\n    if X3_1 >= 0.01 then --C_fourth--\n        if Ball_s[2] < -0.0028 and Ball_s[2] >= -0.2487 then\n            C_K_B_X3()\n        Y3_1 = Y3_1*2.5\n        sim.setJointTargetVelocity(L3,Y3_1)\n        elseif Ball_s[2] >= -0.0028 then\n            C_K_B_X3()\n        Y3_2 = Y3_2*2.5\n        sim.setJointTargetVelocity(L3,Y3_2)\n        elseif Ball_s[2] < -0.2487 then\n            C_K_B_X3()\n        Y3_3 = Y3_3*2.5\n        sim.setJointTargetVelocity(L3,Y3_3)\n        end\n    end\n    --computer2--\n    Body_2_s = sim.getObjectPosition(Body_2,-1)\n    X_2 = Body_2_s[1] - Ball_s[1]\n    Y_2 = Body_2_s[2] - Ball_s[2]\n    if 1 then  --C_goalkeeper\n        if X_2 > -0.02 then\n            sim.setJointTargetVelocity(RR1,-5)\n            sim.setJointTargetVelocity(R1,0)\n            Y_2 = 0\n        elseif X_2 < -0.02 or X_2 > -0.01 then\n            sim.setJointTargetVelocity(RR1,5)\n            YYYYY_2 = Y_2*-7\n            sim.setJointTargetVelocity(R1,YYYYY_2)\n        end\n    end\n \n    Body_2_s2 = sim.getObjectPosition(Body2_2,-1)\n    X2_1_2 = Body_2_s2[1] - Ball_s[1]\n    Y2_1_2 = Body_2_s2[2] - Ball_s[2] - 0.15\n    Y2_2_2 = Body_2_s2[2] - Ball_s[2] + 0.15\n    if X2_1_2 < -0.01 then --C_second--\n        if Ball_s[2] <= -0.133 then\n            C_K_B_X2_2()\n        Y2_1_2 = Y2_1_2*-5\n        sim.setJointTargetVelocity(R2,Y2_1_2)\n        elseif Ball_s[2] > -0.133 then\n            C_K_B_X2_2()\n        Y2_2_2 = Y2_2_2*-5\n        sim.setJointTargetVelocity(R2,Y2_2_2)\n        end\n    end\n \n    Body_2_s4 = sim.getObjectPosition(Body4_2,-1)\n    X4_1_2 = Body_2_s4[1] - Ball_s[1]\n    Y4_1_2 = Body_2_s4[2] - Ball_s[2] - 0.15\n    Y4_2_2 = Body_2_s4[2] - Ball_s[2] + 0.15\n    if X4_1_2 < -0.01 then --C_third--\n        if Ball_s[2] <= -0.133 then\n            C_K_B_X4_2()\n        Y4_1_2 = Y4_1_2*-3\n        sim.setJointTargetVelocity(R4,Y4_1_2)\n        elseif Ball_s[2] > -0.133 then\n            C_K_B_X4_2()\n        Y4_2_2 = Y4_2_2*-3\n        sim.setJointTargetVelocity(R4,Y4_2_2)\n        end\n    end\n \n    Body_2_s3 = sim.getObjectPosition(Body3_2,-1)\n    X3_1_2 = Body_2_s3[1] - Ball_s[1]\n    Y3_1_2 = Body_2_s3[2] - Ball_s[2]\n    Y3_2_2 = Body_2_s3[2] - Ball_s[2] +0.2487\n    Y3_3_2 = Body_2_s3[2] - Ball_s[2] -0.2487\n    if X3_1_2 < 0.01 then --C_fourth--\n        if Ball_s[2] < -0.0028 and Ball_s[2] >= -0.2487 then\n            C_K_B_X3_2()\n        Y3_1_2 = Y3_1_2*-2.5\n        sim.setJointTargetVelocity(R3,Y3_1_2)\n        elseif Ball_s[2] >= -0.0028 then\n            C_K_B_X3_2()\n        Y3_2_2 = Y3_2_2*-2.5\n        sim.setJointTargetVelocity(R3,Y3_2_2)\n        elseif Ball_s[2] < -0.2487 then\n            C_K_B_X3_2()\n        Y3_3_2 = Y3_3_2*-2.5\n        sim.setJointTargetVelocity(R3,Y3_3_2)\n        end\n    end\n    --reborn_ball & count goal--\n    reborn_ball_count_goal()\nend\nfunction C_K_B_X2() --C_second_kick--\n    if X2_1 < 0.06 then\n    sim.setJointTargetVelocity(LR2,-5)\n    elseif X2_1 > 0.03 then\n    sim.setJointTargetVelocity(LR2,5)\n    end\nend\nfunction C_K_B_X3() --C_third_kcik--\n    if X3_1 < 0.06 then\n    sim.setJointTargetVelocity(LR3,-5)\n    elseif X3_1 > 0.03 then\n    sim.setJointTargetVelocity(LR3,5)\n    end\nend\nfunction C_K_B_X4() --C_fourth_kick--\n    if X4_1 < 0.06 then\n    sim.setJointTargetVelocity(LR4,-5)\n    elseif X4_1 > 0.03 then\n    sim.setJointTargetVelocity(LR4,5)\n    end\nend\nfunction C_K_B_X2_2() --C_2_second_kick--\n    if X2_1_2 < -0.03 then\n    sim.setJointTargetVelocity(RR2,5)\n    elseif X2_1_2 > -0.03 then\n    sim.setJointTargetVelocity(RR2,-5)\n    end\nend\nfunction C_K_B_X3_2() --C_2_third_kcik--\n    if X3_1_2 < -0.03 then\n    sim.setJointTargetVelocity(RR3,5)\n    elseif X3_1_2 > -0.03 then\n    sim.setJointTargetVelocity(RR3,-5)\n    end\nend\nfunction C_K_B_X4_2() --C_2_fourth_kick--\n    if X4_1_2 < -0.03 then\n    sim.setJointTargetVelocity(RR4,5)\n    elseif X4_1_2 > -0.03 then\n    sim.setJointTargetVelocity(RR4,-5)\n    end\nend\nfunction reborn_ball_count_goal()\n    if Ball_s[1] < -0.85 and Ball_s[1] > -0.87 then\n        Player_G = Player_G + 1\n    end   \n    if Ball_s[1] >= 0.61 and Ball_s[1] < 0.63 then\n        Computer_G = Computer_G + 1\n    end\n    if Ball_s[1] < -0.85 or Ball_s[1] >= 0.61 then\n        print[[Player : Computer]]\n        print(\'      \'..Computer_G..\'     \'..Player_G)\n    end\n \n    if Ball_s[1] > 0.905 and Ball_s[2] < -0.069 and Ball_s[3] < 0.036 then\n        sim.setJointTargetVelocity(Push_1,1)\n    elseif Ball_s[3] > 0.036 then\n        sim.setJointTargetVelocity(Push_1,-1)\n    end\n    if Ball_s[1] < -1.15 and Ball_s[2] < -0.123 and Ball_s[3] < 0.036 then\n        sim.setJointTargetVelocity(Push_2,-1)\n    elseif Ball_s[3] > 0.036 then\n        sim.setJointTargetVelocity(Push_2,1)\n    end\n \n    if Ball_s[1] < -1.156 and Ball_s[2] > 0.163 and Ball_s[3] > 0.058 then\n    sim.setObjectPosition(Ball,-1,{-0.20361, 0.2739, 0.15735})\n    end\n    if Ball_s[1] < -0.20361 and Ball_s[2] > 0.2740 and Ball_s[3] > 0.15735 then\n    sim.setObjectPosition(Ball,-1,{-0.2049, 0.23, 0.1482})\n    end\n    if Ball_s[1] > 0.9056 and Ball_s[2] <  -0.4247 and Ball_s[3] > 0.0592 then\n    sim.setObjectPosition(Ball,-1,{-0.043425,  -0.60401, 0.15735})\n    end\n    if Ball_s[1] > -0.04753 and Ball_s[2] <  -0.5240 and Ball_s[3] > 0.15735 then\n    sim.setObjectPosition(Ball,-1,{-0.03667,  -0.48443, 0.1482})\n    end\nend \n 檔案: https://github.com/mdecadp2018/site-40623130/blob/gh-pages/v-rep/robot/FinalVersion_EX.ttt \n 人形歸位 \n 我將每根桿件設定成"當按了按鍵變成擊球狀態後會到達邊界數值，如果到達邊界直做減速度運動回到初始狀態"，下方code中為+dVel，其原因是因為原先設定擊球為做減速度運動而回球則加入加速度。 \n \n A= sim.getObjectHandle(\'RS1_PO1\')\nPA= sim.getObjectPosition(A,-1)\nif PA[1] >= -0.712 then\n    Roller_v = Roller_v + dVel*3\nend\nB= sim.getObjectHandle(\'RS2_PO1\')\nPB= sim.getObjectPosition(B,-1)\nif PB[1] >= -0.531 then\n    Roller_v2 = Roller_v2 + dVel*3\nend\nC= sim.getObjectHandle(\'RS4_PO2\')\nPC= sim.getObjectPosition(C,-1)\nif PC[1] >= -0.197 then\n    Roller_v3=Roller_v3 + dVel*5\nend\nD= sim.getObjectHandle(\'RS3_PO1\')\nPD= sim.getObjectPosition(D,-1)\nif PD[1] >= 0.137 then\n    Roller_v4=Roller_v4 + dVel*5\nend \n 檔案: https://github.com/mdecadp2018/site-40623130/blob/gh-pages/v-rep/robot/www2.ttt \n 電腦多人形球位判斷式 \n 將擊球的人行分成三個後，紀錄每兩個人型之間的距離，利用補正讓球穿過人形與人形之間的分界線時，判斷式work，加入補正的數值讓最左或是最右邊的人形能對正球體。 此程式為最初簡易版本。 \n \n 以下都更改於function sysCall_actuation()中 \n -------------------------------------\n               if (auxiliaryData[1]==2008) then\n                Roller_v = Roller_v + dVel*20\n                Roller_v2 = Roller_v2 + dVel*20\n                Roller_v3 = Roller_v3 + dVel*20\n                Roller_v4 = Roller_v4 + dVel*20\n               if (Roller_v < 0) then\n                  Roller_v = 0\n               end\n               if (Roller_v2 < 0) then\n                  Roller_v2 = 0\n               end\n               if (Roller_v3 < 0) then\n                  Roller_v3 = 0\n               end\n               if (Roller_v4 < 0) then\n                  Roller_v4 = 0\n               end\n            end\n-----------------------------------------------\n    --computer--\n    Body_s = sim.getObjectPosition(Body,-1)\n    Ball_s = sim.getObjectPosition(Ball,-1)\n    X = Body_s[1] - Ball_s[1]\n    Y = Body_s[2] - Ball_s[2]\n    if 1 then\n        if X <= 0.02 and Y <= 0 then\n            sim.setJointTargetVelocity(LR1,-5)\n        elseif X > 0.02 and Y <= 0 then\n            sim.setJointTargetVelocity(LR1,2)\n        elseif X <= 0.02 and Y > 0 then            \n            sim.setJointTargetVelocity(LR1,-5)        \n        elseif X > 0.02 and Y > 0 then                \n            sim.setJointTargetVelocity(LR1,2)\n        end\n        YYYYY = Y*7\n        sim.setJointTargetVelocity(L1,YYYYY)\n    end\n \n    Body_s2 = sim.getObjectPosition(Body2,-1)\n    X2_1 = Body_s2[1] - Ball_s[1]\n    Y2_1 = Body_s2[2] - Ball_s[2] - 0.15\n    Y2_2 = Body_s2[2] - Ball_s[2] + 0.15\n    if X2_1 >= 0.02 then\n        if Ball_s[2] <= -0.133 then\n            C_K_B_X2()\n        Y2_1 = Y2_1*5\n        sim.setJointTargetVelocity(L2,Y2_1)\n        elseif Ball_s[2] > -0.133 then\n            C_K_B_X2()\n        Y2_2 = Y2_2*5\n        sim.setJointTargetVelocity(L2,Y2_2)\n        end\n    end\n \n    Body_s4 = sim.getObjectPosition(Body4,-1)\n    X4_1 = Body_s4[1] - Ball_s[1]\n    Y4_1 = Body_s4[2] - Ball_s[2] - 0.15\n    Y4_2 = Body_s4[2] - Ball_s[2] + 0.15\n    if X4_1 >= 0.02 then\n        if Ball_s[2] <= -0.133 then\n            C_K_B_X4()\n        Y4_1 = Y4_1*3\n        sim.setJointTargetVelocity(L4,Y4_1)\n        elseif Ball_s[2] > -0.133 then\n            C_K_B_X4()\n        Y4_2 = Y4_2*3\n        sim.setJointTargetVelocity(L4,Y4_2)\n        end\n    end\n--[[\n    test_s = sim.getObjectPosition(test,-1)\n    M =  test_s[2]- Ball_s[2]\n    print(M)\n--]]\n    Body_s3 = sim.getObjectPosition(Body3,-1)\n    X3_1 = Body_s3[1] - Ball_s[1]\n    Y3_1 = Body_s3[2] - Ball_s[2]\n    Y3_2 = Body_s3[2] - Ball_s[2] +0.2487\n    Y3_3 = Body_s3[2] - Ball_s[2] -0.2487\n    if X3_1 >= 0.02 then\n        if Ball_s[2] < -0.0028 and Ball_s[2] >= -0.2487 then\n            C_K_B_X3()\n        Y3_1 = Y3_1*1.5\n        sim.setJointTargetVelocity(L3,Y3_1)\n        elseif Ball_s[2] >= -0.0028 then\n            C_K_B_X3()\n        Y3_2 = Y3_2*1.5\n        sim.setJointTargetVelocity(L3,Y3_2)\n        elseif Ball_s[2] < -0.2487 then\n            C_K_B_X3()\n        Y3_3 = Y3_3*1.5\n        sim.setJointTargetVelocity(L3,Y3_3)\n        end\n    end\nend\nfunction C_K_B_X2()\n    if X2_1 < 0.03 then\n    sim.setJointTargetVelocity(LR2,-5)\n    elseif X2_1 > 0.03 then\n    sim.setJointTargetVelocity(LR2,5)\n    end\nend\nfunction C_K_B_X3()\n    if X3_1 < 0.03 then\n    sim.setJointTargetVelocity(LR3,-5)\n    elseif X3_1 > 0.03 then\n    sim.setJointTargetVelocity(LR3,5)\n    end\nend\nfunction C_K_B_X4()\n    if X4_1 < 0.03 then\n    sim.setJointTargetVelocity(LR4,-5)\n    elseif X4_1 > 0.03 then\n    sim.setJointTargetVelocity(LR4,5)\n    end\nend \n \n 檔案: https://github.com/mdecadp2018/site-40623130/blob/gh-pages/v-rep/robot/ww5.ttt \n 回球判斷式-無軌道(包含計分判斷式) \n 一開始還沒有導球軌道時，為了不用一直關掉在啟動，寫了一個簡單的回位code，讓球經過球門時，由於球門有判斷式屬於邊界，一通過就會回到設定好的球。 \n 而計分也是利用相通的方法，且由於此程式會自動形成迴圈所以讓他判斷成每當球經過時+1分後回傳。此程式為最初簡易版本。 \n \n 以下都更改於function sysCall_actuation()中 \n \xa0 \n        if 1 then  --C_goalkeeper\n            if X <= 0.02 then\n                sim.setJointTargetVelocity(LR1,-5)\n            elseif X > 0.02 then\n                sim.setJointTargetVelocity(LR1,5)\n            end\n       end\n----------------\n       if Ball_s[1] < -0.85 or Ball_s[1] >= 0.61 then\n            sim.setObjectPosition(Ball,-1,{-0.1429, -0.1334, 0.5})\n       end\n \n \n \n 檔案: https://github.com/mdecadp2018/site-40623130/blob/gh-pages/v-rep/robot/Reborn.ttt \n 偽-回球判斷式-有軌道 \n 也就是送球機構於上一章節的送球機構設計與模擬討論過 \n \n function reborn_ball_count_goal()\n    if Ball_s[1] < -0.85 and Ball_s[3] > 0.12507 then\n        Player_G = Player_G + 1\n--        sim.setObjectPosition(Ball,-1,{-0.13, -0.1334, 0.5})\n    end   \n    if Ball_s[1] >= 0.61 and Ball_s[3] > 0.1251 then\n        Computer_G = Computer_G + 1\n--        sim.setObjectPosition(Ball,-1,{-0.15, -0.1334, 0.5})\n    end\n    if Ball_s[3] > 0.1251 then\n        if Ball_s[1] < -0.85 or Ball_s[1] >= 0.61 then\n            print[[Player : Computer]]\n            print(\'      \'..Computer_G..\'     \'..Player_G)\n        end\n    end\n    if Ball_s[1] > 0.905 and Ball_s[2] < -0.069 and Ball_s[3] < 0.036 then\n        sim.setJointTargetVelocity(Push_1,1)\n    end\n    if Ball_s[1] < -1.15 and Ball_s[2] < -0.123 and Ball_s[3] < 0.036 then\n        sim.setJointTargetVelocity(Push_2,-1)\n    end\n    if Ball_s[3] > 0.036 then\n        sim.setJointTargetVelocity(Push_1,-1)\n        sim.setJointTargetVelocity(Push_2,1)\n    end\n    if Ball_s[1] < -1.156 and Ball_s[2] > 0.163 and Ball_s[3] > 0.058 then\n    sim.setObjectPosition(Ball,-1,{-0.20361, 0.2739, 0.15735})\n    end\n    if Ball_s[1] < -0.20361 and Ball_s[2] > 0.2740 and Ball_s[3] > 0.15735 then\n    sim.setObjectPosition(Ball,-1,{-0.2049, 0.23, 0.1482})\n    end\n    if Ball_s[1] > 0.9056 and Ball_s[2] <  -0.4247 and Ball_s[3] > 0.0592 then\n    sim.setObjectPosition(Ball,-1,{-0.043425,  -0.60401, 0.15735})\n    end\n    if Ball_s[1] > -0.04753 and Ball_s[2] <  -0.5240 and Ball_s[3] > 0.15735 then\n    sim.setObjectPosition(Ball,-1,{-0.03667,  -0.48443, 0.1482})\n    end\nend \n \n 檔案: https://github.com/mdecadp2018/site-40623130/blob/gh-pages/v-rep/robot/C_Goal_4.3.ttt \n 問題與討論 \n Q1.怎麼沒有雙打? \n A1.按鍵過多不好操控，最後會變成賽外賽? \n Q2.彈性係數怎麼調整? \n A2. 彈性系數於球的材質中調整，而材質的調整在關係設定的下方，表中的Restitution就是了最大彈性為1最小為0，越大越彈。 \n \n T3: 反作用設定:包含場地、球、桿件、人形 ((解釋起來很麻煩但大概是這樣 \n 第一個為場地 : 第一行設定讓除了球、人形的桿件能反應但設定第八行讓球、人形可反應但桿件無法，其餘不勾選 \n \n 第二個為球 : 第一行不勾選讓桿件與人行無法反應，但勾選其他行(第八)讓人形能反應 \n \n 第三個為桿件 : 只與場地反應((這裡注意，桿件本身與人型成父子屬性 \n \n 最後是人形 : 勾選第八行讓球反應可踢球且因與場地反應所以不出場地 \n \n 理解這個需要一點邏輯...如果不懂就照勾選吧... \n T4. 運行時建議 先點一下烏龜 太快會增加電腦能力也有機率bug \n \n Q5.怎麼不用python寫?? \n A5.我會選擇使用Vrep內嵌的Lua編寫的原因 \n 優點: \n python : 可執行運算值較大的編譯、可加外部其他的程式合用 \n lua : Vrep內部沿用 , 延遲現象較少、編譯很方便 \n 缺點: \n python : 會有爆ping問題導致延遲、產生很多衝突可能性高 \n lua : 太多運算時直接停止、內部函式限制多 \n 目前體會到的優缺點大概就這樣，而且感覺我們班大部分的人都是用 python\xa0寫，所以我想用少數人用的lua。', 'tags': '', 'url': '系統功能展示.html'}, {'title': '結案報告', 'text': '', 'tags': '', 'url': '結案報告.html'}, {'title': '專案口頭簡報', 'text': '請各組員自行放連結', 'tags': '', 'url': '專案口頭簡報.html'}, {'title': '專案報告書', 'text': '', 'tags': '', 'url': '專案報告書.html'}, {'title': '如何開始編輯報告書', 'text': '下載： https://drive.google.com/file/d/1lH3J-EETOpNruAz86Mi8A4PcKkgJOsh2/view \n 解壓縮完裡面有兩個資料夾 \n \xa0pandoc-2.4-windows-x86_64 和\xa0miktex_portable \n 用SciTE 開啟start.bat \n 並在 path= 的最後方新增 \n \n \n \n \n \n \n 1 \n \n \n \n %Disk%:\\pandoc-2.4-windows-x86_64;%Disk%:\\miktex_portable\\texmfs\\install\\miktex\\bin; \n \n \n \n \n \n \n \n 接著在 cmd(小黑窗) 中輸入 \n \n \n \n \n \n \n 1 \n \n \n \n python -m pip install pandoc-fignos pandoc-tablenos pandoc-eqnos \n \n \n \n \n \n \n \n \n 安裝完成後重新啟動可攜系統即可 \n 參考內容： https://mdecp2018.github.io/finalproject-bgx/content/Kmol-editor.html \n 參考作法： https://mdekmol.github.io/cd2019a-task1-2019cda_t1_g3_1/content/%E5%A6%82%E4%BD%95%E9%96%8B%E5%A7%8B%E7%B7%A8%E8%BC%AF%E5%A0%B1%E5%91%8A%E6%9B%B8.html \n \n 各組完成 html 與 pdf 格式之手足球專案結案報告 (文字結案報告書)', 'tags': '', 'url': '如何開始編輯報告書.html'}, {'title': '第十周前', 'text': '第十周前的網站內容 \n', 'tags': '', 'url': '第十周前.html'}, {'title': 'Task-1', 'text': 'Web \n 取分項目 -工作分配表於3/18開會時分配 \n \n \n \n 第一項 \n 陳鉅忠 \n \n \n 第二項 \n 吳隆廷、郭益綸 \n \n \n 第三項 \n 許高惟、蕭家翰 、林暉恩 \n \n \n \n 若有不小心遺忘的請自行補齊 \n', 'tags': '', 'url': 'Task-1.html'}, {'title': '自定義隨身系統', 'text': '除了老師所提到的幾個重要的程式外，我們還加入老師提起的 Range_Software3 的分析軟體以及自己會用到的電路圖繪製軟體 Fritzing \n \n 都解壓縮完並設定好start批次檔時長這樣 \n \n Range_Software3 \n Github - 老師網誌 \n 是個結合了許多分析又可以繪圖的軟體，但對於操作完全不熟悉 \n \n Fritzing \n 官網 --- 下載 -Windows x64\xa0 Version------ 0.9.3b \xa0 was released on \xa0 June 2, 2016 . \n 我們會選擇此軟體的原因 \n 其一 : 電路學上課時老師推薦過 \n 其二 : 此程式可以編譯至可攜系統中 \n 其三 : 包含了許多大廠的板子且可用code編譯 \n 其四:可調成中文 \n \n 介紹影片 \n 周政叡-40423218 影片 \n 陳柏維-40423136  影片(雜音偏多 \n 許育誠-40423160\xa0 影片 \n 吳隆廷-40623115\xa0 影片 \n 陳鉅忠-40623130\xa0  影片 (聲音偏小 \n 蕭家翰-40623133   影片 \n 許高惟-40623139 \xa0 影片 \n 郭益綸- 40623142   影片 \n 林暉恩- 40623145   影片 \n \xa0 劉 奇\xa0 -40623146\xa0 影片 \n', 'tags': '', 'url': '自定義隨身系統.html'}, {'title': '隨機分組介面成品', 'text': '算是半成品的GUI介面 \xa0。 \xa0\xa0------>  成品 \n 說是半成品理由是 太多的理想面想法但能力不足... 我要把自己淘汰掉了。 \n 原本來想設計有存檔 、分行、直接編輯等功能 , 但真的沒那個能力可能要問問學長他們 , 之後還想轉成.exe檔 , 但現階段光下載 \xa0 pyinstaller 就一堆error啦...而且也要換成pyside2了可能就先放著去研究其他東西吧。 \n 還想用個GUI介面 , 是關於start.bat的 , 點擊後只跳出黑白窗各一個&一個點擊介面可以直接叫各程式的介面然後還能自己添加程式的功能 ( ( ( 科技進步出於人類的慾望--懶惰。 \n ----------------------------------------------------------- \n 利用大一學過的eric6設計生成的介面code \n \n 這段code位於Ui_task.py下方 , 主要是為了與下方程式task.py作聯結的code \n \n 按鈕主要的code設計 , 部分作小修改 \n PBsave鈕目前只有裝飾功能 , 尚未編譯 \n \n 這是執行後面介面樣子 \n \n 執行.txt檔後分出的組別排序 , 意想不到的是竟然可以讀取中文檔名的文件 \n \n Combine1.1&1.2 \n 測試結合  項目一 以及 項目二 \xa0, 其結果是只顯示出組長 \n \n 問題 :\xa0 \n eric6底下出現 " Qt: Untested Windows version 10.0 detected! " 此\xa0 連結 \xa0或許能改善 , 還在測試 \n 成品 \n 完成啦 - 69MB左右。 \n 完全沒想到轉成exe檔會大成這樣... \n 不過上星期到這次改版差了很多,不但整合了項目一與二 , 還修改了save as 按鈕(可用) , 還轉成了exe檔...很難想像因為一個enter換行導致一串的bug , 不過還是成功修改好了。 \n 改版Save as 按鈕成可用code , 並可直接存成.txt檔案 之後利用 pyinstaller(官方下載說明頁面) 測試看看能否轉py成exe檔案 , 但是明顯的出了幾個bug (1) cffi 過舊或是未安裝 --->需更新檔案---->pip cffi 就可以了\xa0 \xa0 \xa0( 沒記錯的話 (2)接下來是下方這個 , 黑窗表示 : 語法錯誤 \n \n 上網查後發現是下方這個.py檔的198行的空白行的問題... \n 刪除開白行即可 \n 之後就可正常用行囉 , pyinstaller會生成很多檔案而主要的exe檔在dist資料夾中 \n \n 之後到要轉檔的目錄位置打 pyinstaller -F -w -i 圖.ico 主程式.py -p 其餘程式\xa0-p 其餘程式\xa0\xa0-p 其餘程式\xa0\xa0-p 其餘程式\xa0 \n 以下為pyinstaller常用參數介紹 \n \n pyinstaller -h 來查看參數 \n -F : 打包成一個exe文件 \n –i 圖.ico : 更改ico圖示 \n -w : 使用視窗，無控制台 \n -c : 使用控制台，無視窗 \n -D : 創建一個目錄，包含exe以及其他一些依賴性文件 \n \n \n 完成品~ \n \n', 'tags': '', 'url': '隨機分組介面成品.html'}, {'title': '分組程式修正', 'text': '在利用亂數分組, 能否根據已經完成的主程式, 編寫一個網際程式或單機 PyQt5 程式, 讀進相關資料檔案後, 在瀏覽器或 PYQt5 程式中顯示出結果. \n import random \nfilename = \'cdbw3_student_list.txt\' \n# 每組人數 \nnum_in_one_group = 11 \n# 組序由 1 開始 \ngroup = 1 \n# 各班分組後所得數列 \nc2019 = [] \nwith open(filename) as f: \n    # 讀進全部檔案, 轉進數列, 並同時將各行的 \\n 去除 \n    read_data = f.read().splitlines()  \nprint("共有 " + str(len(read_data)) + " 位學員") \n# 利用 shuffle 將數列隨機弄亂 \nrandom.shuffle(read_data) \nfor i in range(len(read_data)): \n    # 利用整數相除的餘數進行分組 \n    if i%num_in_one_group == 0: \n        # 列出分隔符號 \n        print("-"*20) \n        print("group " + str(group) +":") \n        # 在分組區隔時重置各組學員數列 \n        group_list = [] \n        print() \n        # 同時列出與分隔標註對應 i 的數列內容 \n        print(read_data[i]) \n        group_list.append(read_data[i]) \n        group = group + 1 \n    else: \n        # 逐一列出同組的其他學員 \n        print(read_data[i]) \n        group_list.append(read_data[i]) \n    if i%num_in_one_group == 0: \n        c2019.append(group_list) \n# c2019 為該班分組後所得分組數列 \nprint(c2019) \n 原始程式只有將檔案cdbw3_student_list.txt讀進Python程式中做亂數分組 \n import random \nfilename = \'cdbw3_student_list.txt\' \n# 每組人數 \nnum_in_one_group = 8 \n# 組序由 1 開始 \ngroup = 1 \n# 各班分組後所得數列 \nc2019 = [] \nwith open(filename) as f: \n    # 讀進全部檔案, 轉進數列, 並同時將各行的 \\n 去除 \n    read_data = f.read().splitlines()  \nprint("共有 " + str(len(read_data)) + " 位學員") \n# 利用 shuffle 將數列隨機弄亂 \nrandom.shuffle(read_data) \nfor i in range(len(read_data)): \n    # 利用整數相除的餘數進行分組 \n    if i%num_in_one_group == 0: \n        # 列出分隔符號 \n        print("-"*20) \n        print("group " + str(group) +":") \n        # 在分組區隔時重置各組學員數列 \n        group_list = [] \n        print() \n        # 同時列出與分隔標註對應 i 的數列內容 \n        group_list.append(read_data[i]) \n        group = group + 1 \n        print("Leader:"+read_data[i]) \n    else: \n        print("Member:"+read_data[i]) \n    if i%num_in_one_group == 0: \n        c2019.append(group_list) \n# c2019 為該班分組後所得分組數列 \n \nprint("Group_leader"+str(c2019)) \n \n 在i 迴圈當中加入if i %num_in_one_group == 0: 檢驗ｉ除上組員數量是否=0 \n 假設等於0\xa0 \xa0 (整除無餘數) \n print("Leder:"+read_data[i])組長應是第一位選出來(read_data[i]) \n 假設不等於0\xa0 \xa0 (無整除) \n else: 其他的人為組員("Member:"+read_data[i]) \n 結果如下 \n \n 最下方為各組組長的顯示結果 \n', 'tags': '', 'url': '分組程式修正.html'}, {'title': 'ungit使用手冊', 'text': '老師的影片: \n \n 1.下載 ungit 與 node.js 程式碼 首先下載 \xa0 kmol_2019.7z , 接著再下載 \xa0 nodejs_with_ungit.7z , 兩者分別解開壓縮檔案, 然後將 nodejs 放入 kmol_2019 的 data 目錄中. \n 2.設定命令列搜尋路徑 \n 接下來設定啟動 start.bat 中的 ungit 命列列搜尋路徑: \n 新增 set path8=%Disk%:\\nodejs;%Disk%:\\nodejs\\appdata\\roaming\\npm; (抓取nodejs主程式路徑) \n path=%path%;%path1%;%path2%;%path3%;%path4%;%path5%;%path6%;%path7%;%Disk%:\\p37\\site-packages\\scipy\\extra_dll;%Disk%:\\scite\\bin; %path8%; \n \n 3.設定 USERPROFILE 環境變數 \n 讓 node.js 能夠使用 y:\\home 作為使用者目錄, 在 start.bat 中加入 set USERPROFILE=%Disk%:\\home \n \n 4. 以 SciTE 編輯器存入 Y:\\kungit.bat 批次檔案中 \n 為了對應 "C:\\Program Files (x86)", 針對目前所在的倉儲目錄, 以 Google Chrome 瀏覽器開啟 ungit 的網際倉儲連結. \n 新增批次檔 \n ungit --launchBrowser=0 --launchCommand "C:\\PROGRA~2\\Google\\Chrome\\Application\\chrome.exe\xa0 %%U" \n (指令內的PROGRA~2為Program file(x86)之縮寫，此外PROGRA~1為Program Flies縮寫) \n 為了跟ungit做一個區別批次檔名稱改成kungit並存在y:/底下 \n \n \n 5.開啟 start.bat， 輸入 kungit 後，會在瀏覽器中開啟ungit頁面 \n \n 6.利用ungit進行協同作業比原本使用cmd來的快速也較容易能判斷版本之間的改動 \n \n Title :可以輸入中文標題 \n Body :可以增加內容 讓其他協同組員知道這個版本增加什麼 \n Commit按鈕 : 可以不使用cmd指令就直接commit以節省時間 \n \n Push按鍵 : commit完成之後只要按版本旁邊的push就能將版本推到遠端 \n \n 每項commit在紅框內的視窗都有檔案的詳細資訊 \n 總結 : 這真的很方便， 唯二碰到的問題都是start的路徑沒有設定好 \n', 'tags': '', 'url': 'ungit使用手冊.html'}, {'title': '問題', 'text': '問題一 : Scite一直出現此錯誤且作者目前無解的問題 1.   2. \n \n 問題二 : Range 及 Fritzing 要存取檔時無法讀取Y槽，但是!!還是可以用? \n \n 問題三:ungit錯誤，結果是網路的問題! \n \n', 'tags': '', 'url': '問題.html'}, {'title': 'Task-2', 'text': 'Web \n', 'tags': '', 'url': 'Task-2.html'}, {'title': 'Vrep', 'text': 'BubbleRob \n 教學WEB \n \n 可作動 \n BubbleRob操作手冊 \n 1.建立BubbleRob本體 新增一個 Sphere ， X-size 為 0.2( 單位為m) 在 object common properties 下的 object special properties (特殊屬性參數)將 Collidable(可碰撞)、Measurable(可測量)、Renderable(可渲染)、Detectable(可檢測) 都打勾，將本體位置設定在Z軸(Along Z)0.02(必須確認本體是依照world去移動) 接著在選單雙擊Sphere將物件名稱改為BubbleRob就完成本體設定。 \n \n 2.建立Proxmity sensor(接近傳感器) 在選單中建立一個 Proximity sensor 且選為 Cone type (錐形) \n 將sensor利用旋轉功能在 Around Y及Z 輸入 90 位置為 X-coord 輸入 0.1 及 Z-coord 輸入 0.12 \n \n \n 接著設定sensor感應範圍，在選單點擊感測器符號開啟它的設定框，點擊 show volume\xa0 \n parameter (體積參數)開啟選單設定 Offset=0.005、Angle=30、Range=0.15 \n \n 點擊 Show detection parameters (檢測參數)，將 "Don\'t allow detections if distance smaller than" 選項取消打勾。 \n 將感測器名稱設定為 bubbleRob_sensingNose ，就完成感測器設定了。 \n 在 Scene hireachy (場景等級)將完成設定的sensor放在bubbleRob下 \n 最後將兩項物件 Edit->"Make last selected object parent" 連結成一個物件。 \n 3.建立bubbleRob的輪子 \n 建立一個 cylinder 尺寸為(0.08,0.08,0.02)，跟本體一樣將 object common properties 內的特殊屬性都打開，設定位置(0.05,0.1,0.04)和旋轉(-90,0,0)，此物件命名為 bubbleRob_leftWheel ，然後將完成的物件複製一份且將位置參數Y設定為-0.1，此物件命名為 bubbleRob_RightWheel \n 設定 joint (motor) Add->joint->Revolute (迴轉)建立一個軸，建立完成按住ctrl選擇剛剛的 bubbleRob_leftWheel 然後在 postion (位置)及 \xa0 orientation (方向)內選擇 apply to selection 來複製輪子的參數，這樣軸的位置就會跟左邊輪子一樣了。 點擊開啟軸參數的設定框，將 \xa0Show dynamic parameters (動態參數)內的 enable the motor 以及底下的 Lock motor when target velocity is zero 都打勾，完成左邊輪軸設定後，用同樣方式製作右輪軸。 \n 最後將輪子層級放置在輪軸底下，輪軸層級則置於本體下 \n \n 4.建立slider(滑塊) 開始模擬後發現機器人會向後翻轉，因為少了第三個接地點 建立一個圓形物件(設定0.05)，一樣打開所有特殊屬性，將此物件命名為 \xa0bubbleRob_slider ，在 shape dynamics properties 裡將物件設定為 無摩擦 。 \n 摩擦力相關的係數都調成0 \n \n 接著建立 Force sensor (力感測器)命名為 bubbleRob_connection ，將它往上提0.05 ，再跟剛剛的滑塊接合成一個物件，這個物件的位置設定X=(-0.07)，此物件的層級則放在bubbleRob底下，這樣就完成第三個接地點了，但是執行模擬後會發現滑塊會微微震動，那是因為滑塊跟本體互相碰撞了，為了避免這種狀況，開啟滑塊及本體的 shape dynamics properties 將 local respondable mask 分別設定為00001111及 11110000這樣兩個物件就不會互相碰撞了。 \n 滑塊設定 \n \n 本體設定 \n \n 5.增加穩定性(stability)及目標速度( Target velocity )測試 點擊dynamic對話框內的 M=M*2 選項三次將輪子以及第三個支點的重量變成8倍，接著在軸的dynamic對話框將 Target velocity 設至50後開始演算，會發現bubbleRob會穩定的直線前進最後掉出平台，然後再將速度重置為0，測試就完成了。 \n \n 6. collection object (物品集)及 Calculation module properties (計算模組) 在collection對話框內用 Add new collection ，新增的集合是空的，將列表上的bubbleRob選擇後點選Add加進collection，命名為  bubbleRob_collection  ，這樣bubbleRob底下的零件都包含集合裡。 在選單點選 Calculation module 在 distance (距離)下 Add new distance object ， 選擇剛剛新增的 bubbleRob_collection 及 all other measurable objects in the scene ， 命名為 bubbleRob_distance ，這個設定在之後會測量本體以及其他可碰撞物件之間的最小距離。 \n \n 7.Graph(圖表)設定 新增一個Graph命名為 bubbleRob_graph 在列表上放置於bubbleRob底下將graph位置設定在(0,0,0.005)開啟graph properties，將 Display XYZ-planes 選項取消打勾，接著 Add new data stream to record ，視窗上方 (Data stream type) 選擇 Object: absolute x-position 下方 (Object / item to record) 選擇 bubbleRob_graph ，在 Data stream recording list 會出現剛剛新增的設定，Y軸跟Z軸也用同樣方式做設定。 \n 為了能夠測量機器人跟環境之間的最小距離再新增一個設定上面選擇 Distance:segment length 下方選擇 bubbleRob_distance 。 \n \n 將XYZ軸及距離設定分別命名為 bubbleRob_xpos、bubbleRob_ypos、bubbleRob_zpos、 bubbleRob_obstacle_dist 。 \n \n 選擇bubbleRob_xpos在底下的 Time graph properties 將Visible取消掉，其他兩軸也用相同方式操作。 \n 接著在 Edit 3D curves 點選  Add new curve 設定如圖 \n \n Curve width (線寬)設定為4，然後改成 Relative to world ，完成後測試就會發現機器人的路徑會以線顯示在螢幕上。 \n 8.建立cylinder \n 增加數個(0.1,0.1,0.2)的cylinder包圍bubbleRob，將cylinder的特殊屬性參數全部打開，移動cylinder途中按著shift可以進行更細微的移動，按住ctrl則可以讓物件可以在正交方向移動。 \n 9.model設定 選擇bubbleRob後在 object common properties 內將 Object is model base 和 Object/model can transfer or accept DNA 都打勾，這樣bubbleRob邊界框就包含底下所有的物件在內了。 \n \n 接著將兩個joint、sensor跟graph都選起來然後將參數設定 ignored by model bounding box ，讓模型的邊界框略過sensor跟joint然後將joint跟sensor的camera visibility layer 2取消打勾改為打勾10，這樣在畫面上就不會看見軸跟sensor範圍了，最後將感測器、兩個輪子、支點、圖表的 Select base of model instead 都打勾，這項設定讓我們只能一次移動整個機器人而不是單個零件，能避免定位好的零件被移動。 \n \n (vrep版本3.6.1沒有 Don\'t show as inside model selection 按鈕) \n 10.感測器(vision sensor) 增加一個新的感測器，位置、角度跟BubbleRob\'s proximity sensor同樣，在畫面上點選增加 Perspective type 的sensor，然後放到proximity sensor底下，新的sensor設定如下 \n \n 接著點擊 Show filter dialog 開啟filter對話框，選擇 Edge detection on work image 然後按 Add ，新增的過濾組件要上移至第二層，移動完後點擊兩下剛剛設定的組件將 Threshold (閾值)設定為0.2，設定到這邊基本上就完成了。 \n \n 完成sensor設定後新增一個 floating view 然後在它上面右鍵選擇 (view->Associate view with selected vision sensor) 將視窗綁定到剛剛設定完的sensor上(操作中間要確保sensor是被選擇的狀況)，接著試著開始模擬，視窗上能夠看見目標就成功了。 \n \n 11.程式: 位於工具列的script功能可以編輯code \n \n 最後的步驟要將code放進完成的模型內，選擇bubbleRob點選( Add->Associated child script --> Non threaded ) \n \n 新增一個 non-threaded child script ，接著點選bubbleRob旁邊的圖示(如附圖) 就能打開script，將code複製在原本的code後面關掉視窗就完成了。 \n \n 需注意code內部\xa0 \n \n leftMotor=sim.getObjectHandle(" bubbleRob_leftMotor ") -- Handle of the left motor rightMotor=sim.getObjectHandle(" bubbleRob_rightMotor ") -- Handle of the right motor noseSensor=sim.getObjectHandle(" bubbleRob_sensingNose ") -- Handle of the proximity sensor \xa0 紅框內的名稱，如果大小寫或是名稱不同程式就沒辦法成功執行。 \n \n 成功的bubbleRob在模擬時會自動避開路徑上的物件，並且畫面會有能調節速度的面板。 \n', 'tags': '', 'url': 'Vrep.html'}, {'title': 'Vrep-2', 'text': "試著用鍵盤的前後左右測試robot -\xa0 Download \n \n 參考網址: http://www.forum.coppeliarobotics.com/viewtopic.php?t=1575&p=6085#p6065 \n \n week7測試物件 \n 測試用Vrep呼叫方向鍵的指令 \n \n \n (內建程式推不上去改用截圖放) \n ------------------------------------------------------------------------------------------------------------ \n 測試方向鍵於手足球的人偶自由度&code設定 :\xa0 \n RJ1 : 為人偶前後踢球的軸代稱\xa0 \\\xa0 RJ2 :\xa0 為控制人偶左右的桿子的軸代稱 \n 樹狀圖為gif中所表示 \n \n 下方為Lua code --->用於Vrep3.6.1版本中\xa0 \n function sysCall_init()  \n    right_left_handle= sim.getObjectHandle('RJ1') \n    up_down_handle= sim.getObjectHandle('RJ2') \n    MaxVel=5 \n    right_left_velocity=0 \n    up_down_velocity=0 \n    dVel=0.5; \n    sim.setJointTargetVelocity(right_left_handle,right_left_velocity) \n    sim.setJointTargetVelocity(up_down_handle,up_down_velocity) \nend \n \nfunction sysCall_actuation()  \n    message,auxiliaryData=sim.getSimulatorMessage() \n    while message~=-1 do \n        if (message==sim.message_keypress) then \n            if (auxiliaryData[1]==32) then \n                -- right key \n                right_left_velocity=0 \n                up_down_velocity=0 \n                sim.setJointForce(right_left_handle, 0) \n                sim.setJointForce(up_down_handle, 0) \n                break \n            else \n                sim.setJointForce(right_left_handle, 10000) \n                sim.setJointForce(up_down_handle, 10000) \n            end \n            if (auxiliaryData[1]==2007) then \n                -- left key \n                right_left_velocity=right_left_velocity+dVel*1.3 \n            end \n            if (auxiliaryData[1]==2008) then \n                -- right key \n                right_left_velocity=right_left_velocity-dVel*1.3 \n            end \n            if (auxiliaryData[1]==2009) then \n                -- up key \n                up_down_velocity=up_down_velocity+dVel/10 \n            end \n            if (auxiliaryData[1]==2010) then \n                -- down key \n                up_down_velocity=up_down_velocity-dVel/10 \n            end \n        end \n        message,auxiliaryData=sim.getSimulatorMessage() \n    end \n     \n    if right_left_velocity>MaxVel then \n        right_left_velocity=-5 \n    end \n    if right_left_velocity<-MaxVel then \n        right_left_velocity=5 \n    end \n     \n    if up_down_velocity>MaxVel then \n        up_down_velocity=0 \n    end \n    if up_down_velocity<-MaxVel then \n        up_down_velocity=0 \n    end \n     \n    sim.setJointTargetVelocity(right_left_handle,right_left_velocity) \n    sim.setJointTargetVelocity(up_down_handle,up_down_velocity) \n     \nend  \n 測試版本目前還未設定雙判定來改變控制的桿件(希望能行)&還有電腦的回擊也還沒寫入。 \n \n keyboard code 設定 {Unicode} :\xa0 \n http://www.runoob.com/try/try.php?filename=tryjsref_event_key_keycode \n \n week8測試物件 \n \n 嘗試將兩軸分開控制，由於我們是利用加速度來驗算所以在編寫code方面較為複雜，目標為利用鍵盤按鍵分別控制各軸，達成一次控制一軸且可切換之目標。 \n", 'tags': '', 'url': 'Vrep-2.html'}, {'title': 'Onshape', 'text': '圖檔位置 \n (1) 人形 : \n https://cad.onshape.com/documents/8c0be159fdc3c8e13fb701bf/w/d1d5f612592d280c6171a6b4/e/af8ccadea4c6f59a5ea6537c \n \n (2) 場地:\xa0 \n \xa0 https://cad.onshape.com/documents/0894dee7161cb625fbf66c24/w/dd82ba727b43d8551157d048/e/4e12526592dd2e271bca4ad7 \n \n 場地零件: \n \n \n \n \n 球: \n \n 場地增加: \n \n (3) 完成品:\xa0 \n \n 後來發現其實直接畫在一個零件裡就夠了,不然有些地方很難修改 \n 於是我們將場地精簡成這樣 \n \n 最終版本: \n \n', 'tags': '', 'url': 'Onshape.html'}, {'title': 'Extra-add', 'text': '擋球軌道 : \n https://cad.onshape.com/documents/4984320cf758c826a317595a/w/c314b8f3e5b6a9397411a635/e/56767dcb9a4bb6e5aa635f63 \n \n', 'tags': '', 'url': 'Extra-add.html'}, {'title': 'Final-handball', 'text': '尚未完成部分 :\xa0 \n \n \n \n 1 . 電腦操控一支桿件的回擊程式編譯 \n \n \n 2 .電腦操控多支桿件的回擊程式編譯 \n \n \n 3 . 玩家對桿件的切換程式編譯 \n \n \n 4 . 導球機構 \n \n \n 5 . \xa0 簡化 \n \n \n 6 . 計分設計 \n \n \n \n \n 不簡化的下場...死機十幾分鐘以上 \n 以下僅外觀 , 使用請小心 7z \n \n', 'tags': '', 'url': 'Final-handball.html'}, {'title': '期中報告', 'text': '嵌入期中報告影片 \n 周政叡-40423218 :\xa0 \n \n 陳柏維-40423136\xa0:\xa0 \n \n 吳隆廷-40623115\xa0:\xa0 \n \n 陳鉅忠-40623130 \xa0:\xa0 \n \n 蕭家翰-40623133 \xa0:\xa0 \n \n 許高惟-40623139 \xa0:\xa0 \n \n 郭益綸- 40623142 \xa0:\xa0 \n \n 林暉恩- 40623145 \xa0:\xa0 \n \n \xa0  劉 奇\xa0 -40623146\xa0:\xa0 \n', 'tags': '', 'url': '期中報告.html'}, {'title': 'Virtualbox虛擬主機網路設定', 'text': 'Step1：前往 雲端載點 將檔案UB1804下載下來。 \n Step2：開啟Oracle VM VirtualBox Manager。 \n Step3：點擊右方視窗中的"NEW"按鈕來新增虛擬主機(名稱可隨意)，按下NEXT。 \n Step3：將Memory size調到4GB，按下NEXT。 \n Step4：將Hard disk選擇Use an existing virtual hard disk file(選項第三個)。 \n Step5：選擇檔案右方按鈕尋找"ub1804"檔案按下確定。 \n Step6：回到主畫面，點擊剛剛建立的虛擬主機ub1804，點擊右方視窗中的Setting前往設定。 \n Step7：左方選單中選擇Network，在右方視窗的Attached to選單中選擇Bridged Adapter(當使用者需要利用虛擬主機建立與 Host 位階相同的網路模式時，可以將虛擬主機的網卡設訂為 Bridged Adapter.)，確認後按下OK。 \n Step8：回到主畫面，啟動剛剛設定好的檔案，在右方視窗按下Start。 \n Step9：輸入帳號密碼(帳號：kmol2019密碼：kmol2019) \n Step10：可以輸入 ifconfig 來查看IP。 \n Step11：輸入 cd /etc/netplan 按下Enter後，輸入1s -1按下Enter。 \n Step12：輸入 sudo vi 50-clould-init.yaml按下Enter。 \n Step13：輸入密碼kmol2019，前往設定。 \n (上下左右為 K J H L) \n 步驟14：dhcp4：false  \u3000\u3000\u3000\u3000地址：192.168.56.2/24  gateway4  \u3000\u3000\u3000\u3000：192.168.56.1 \n Step15：編輯完成按下Ctrl+C退出，然後輸入sudo netplan apply同意設定。 \n Step16：輸入ifconfig 檢查ip。 \n Step17：輸入sudo survice cmsimfly restart重新啟動。 \n 影片如下： \n \n', 'tags': '', 'url': 'Virtualbox虛擬主機網路設定.html'}, {'title': '換行code 改寫', 'text': '圖中寫到 : 因html中可能還有中文字元在尚未喘成unf8時會出現語法錯誤 , 所以轉成unf8換完行後再轉回原本的字元 \n 如右邊所呈現有成功換行 \n \n code: \n # encoding=utf8\nimport re\n\nrep = {"h1": "h2", "h2": "h3", "h3": "h4"} # define desired replacements here\n\n# use these three lines to do the replacement\nrep = dict((re.escape(k), v) for k, v in rep.items())\npattern = re.compile("|".join(rep.keys()))\n\n#text = pattern.sub(lambda m: rep[re.escape(m.group(0))], text),editing by 40623130\n\nresult = pattern.sub(lambda m: rep[re.escape(m.group(0))],"""\n\n""")\n\nprint(result) \n \n', 'tags': '', 'url': '換行code 改寫.html'}, {'title': '圖形簡化', 'text': '球桿簡化 \n \n', 'tags': '', 'url': '圖形簡化.html'}, {'title': '第十一周', 'text': '開會紀錄 \n \n', 'tags': '', 'url': '第十一周.html'}, {'title': '第十二周', 'text': "開會紀錄 \n \n ----暫時放著---- \n 改寫code=python to lua並簡化 \n 優點: \n python : 可執行運算值較大的編譯 \n lua : Vrep內部沿用 , 延遲現象較少 \n 缺點: \n python : 會有爆ping問題導致延遲 \n lua : 太多運算時直接停止 \n \n \n function sysCall_init() \n    KickBallV = 10\n    R_KickBallVel = (math.pi/180)*KickBallV\n    B_KickBallVel = -(math.pi/180)*KickBallV\n    Sphere_handle=sim.getObjectHandle('Sphere')\n    BRod_handle=sim.getObjectHandle('BRod')\n    BRev_handle=sim.getObjectHandle('BRev')\n    BMo_handle=sim.getObjectHandle('BMo')\n    --\n    RRod_handle=sim.getObjectHandle('RRod')\n    RRev_handle=sim.getObjectHandle('RRev')\n    RMo_handle=sim.getObjectHandle('RMo')\nend\nfunction sysCall_actuation()\n    position_BR=sim.getObjectPosition(BRod_handle,-1)\n    position_S=sim.getObjectPosition(Sphere_handle,-1)\n    X =position_S[1] - position_BR[1]\n    Y =position_S[2] - position_BR[2]\n    if 1 then\n        if X <= 0.02 and Y <= 0 then\n            sim.setJointTargetVelocity(BRev_handle,B_KickBallVel)\n            sim.setJointTargetVelocity(BRev_handle,-1)\n        elseif X > 0.02 and Y <= 0 then\n            sim.setJointTargetVelocity(BRev_handle,B_KickBallVel)\n            sim.setJointTargetVelocity(BRev_handle,1)\n        elseif X <= 0.02 and Y > 0 then            \n            sim.setJointTargetVelocity(BRev_handle,R_KickBallVel)\n            sim.setJointTargetVelocity(BRev_handle,-1)        \n        elseif X > 0.02 and Y > 0 then            \n            sim.setJointTargetVelocity(BRev_handle,R_KickBallVel)    \n            sim.setJointTargetVelocity(BRev_handle,1)\n        end\n        YYYYY = Y*5\n        sim.setJointTargetVelocity(BMo_handle,YYYYY)\n    end\n---\n    position_RR=sim.getObjectPosition(RRod_handle,-1)\n    X =position_S[1] - position_RR[1]\n    Y =position_S[2] - position_RR[2]\n    if 1 then\n        if X <= 0.02 and Y <= 0 then\n            sim.setJointTargetVelocity(RRev_handle,B_KickBallVel)\n            sim.setJointTargetVelocity(RRev_handle,-1)\n        elseif X > 0.02 and Y <= 0 then\n            sim.setJointTargetVelocity(RRev_handle,B_KickBallVel)\n            sim.setJointTargetVelocity(RRev_handle,1)\n        elseif X <= 0.02 and Y > 0 then            \n            sim.setJointTargetVelocity(RRev_handle,R_KickBallVel)\n            sim.setJointTargetVelocity(RRev_handle,-1)        \n        elseif X > 0.02 and Y > 0 then            \n            sim.setJointTargetVelocity(RRev_handle,R_KickBallVel)    \n            sim.setJointTargetVelocity(RRev_handle,1)\n        end\n        YYYYY = Y*5\n        sim.setJointTargetVelocity(RMo_handle,YYYYY)\n    end\nend\n--by 40623130-- \n ttt檔 \n 原本要編寫切換鍵但於vrep中用io.clock等時間等待輸入雙命令時會出現運算值過大導致停止問題 , 所以先寫電腦打擊與跟蹤球 \n 原python code出處(by 40623128): https://mdekmol.github.io/cd2019a-task1-2019cda_t1_g3_1/content/%E6%89%8B%E8%B6%B3%E7%90%83%E6%89%8B%E6%8E%A7%E8%88%87%E9%9B%BB%E8%85%A6%E5%B0%8D%E6%89%93.html \n", 'tags': '', 'url': '第十二周.html'}, {'title': '第十三周', 'text': '', 'tags': '', 'url': '第十三周.html'}, {'title': 'V-rep簡化', 'text': '簡化目的是要把繁瑣的圖形切割，變成比較簡單的圖形切割，程式在模擬的時候將會變得順暢。 \n \n 利用V-rep裡面的 Manual mesh division(手動分割網格)來合併圖塊。 \n \n 圖形簡化後變成許多圖塊。 \n \n 完成之後合併圖塊。 \n \n 檔案位址：\u3000 ./../downloads/40623115(group).7z \n 各零件的圖形簡化如上面步驟： \n 人形-分割 \n \n 人形-簡化 \n \n 桿件-分割 \n \n 桿件-簡化 \n \n 檔案位址： ./../downloads/人形.7z \n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0\xa0 ./../downloads/桿件.7z \n 球台兩側簡化 \n \n 問題：簡化後的圖形無法合成成一整體?! \n 球台修正 \n \n \n 檔案位址： ./../downloads/球台兩側-簡化.7z \n \n \n 參考資料： https://www.cnblogs.com/21207-iHome/p/6704194.html \n', 'tags': '', 'url': 'V-rep簡化.html'}, {'title': '第十四周-簡化', 'text': '檔案:第一版  簡化版本1 \n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0第二版  簡化版本2 \n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0第三版 簡化版本3 \n 完成品 \n \n 球員分布 \n \n 組合中發現球員與軸向偏差，在組合時修正 \n \n 側視圖 \n \n 因組員反應高度無法擊球，故在高度上進行調整 \n \n 桿件隱藏 \n \n 實際作動物件及外觀在組合時需注意位置及方向，作動的簡化物件在圖上隱藏。 \n 5/27更新 \n 第一版本 \n \n 預設的第一個版本 \n 第二版本 \n \n 經小組員討論，將多餘的空格消除，同時也是球員往下修正之版本 \n 第三版本 \n \n 測試後證實，原球軌入球口會卡住球，故第三版本將側面孔完全消除。 \n 第四版本(目前測試版本) \n \n \n 將原先設計的突起及角落圓角消除，讓模擬更順暢。 \n', 'tags': '', 'url': '第十四周-簡化.html'}, {'title': '編輯報告書', 'text': '下載： https://drive.google.com/file/d/1lH3J-EETOpNruAz86Mi8A4PcKkgJOsh2/view \n 解壓縮完裡面有兩個資料夾 \n \xa0pandoc-2.4-windows-x86_64 和\xa0miktex_portable \n 用SciTE 開啟start.bat \n 在path=的最後方新增： \n %Disk%:\\pandoc-2.4-windows-x86_64;%Disk%:\\miktex_portable\\texmfs\\install\\miktex\\bin; \n \n 接著在cmd (小黑窗) 中輸入： \n python -m pip install pandoc-fignos pandoc-tablenos pandoc-eqnos \n 安裝完成後重新啟動可攜系統即可 \n 參考內容： https://mdecp2018.github.io/finalproject-bgx/content/Kmol-editor.html \n 參考作法： https://mdekmol.github.io/cd2019a-task1-2019cda_t1_g3_1/content/%E5%A6%82%E4%BD%95%E9%96%8B%E5%A7%8B%E7%B7%A8%E8%BC%AF%E5%A0%B1%E5%91%8A%E6%9B%B8.html \n \n 各組完成 html 與 pdf 格式之手足球專案結案報告 (文字結案報告書) \n', 'tags': '', 'url': '編輯報告書.html'}, {'title': '第十五周', 'text': '完成手足球程式編譯，剩下場地修改，由於組員軌道製作時間過長所以先用程式寫回球。 \n 當中有很多版本，從{多桿件設定與測試} →{多桿件回位設定與測試}→{導入電腦對打&第二桿件電腦判斷添加}→{加入電腦對打&第二及三桿件電腦對打code}→{第四桿件電腦回擊設定}→{球重生&左下計分}，沒意外下個版本就可以結束了。((全寫在lua中 \n 影片是照順序放der \n 檔案也是 1 → 2 → 3 → 4 → 5 → 6\xa0 → 7 \n \n \n \n \n 目前最新版本 \n \n ↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓ \n 目前最新版本 \n \n ↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓ \n function sysCall_init()\n    Ball=sim.getObjectHandle(\'ball\')\n    --player--\n    Slide_rail= sim.getObjectHandle(\'R1\')\n    Roller= sim.getObjectHandle(\'RR1\')\n    Slide_rail2= sim.getObjectHandle(\'R2\')\n    Roller2= sim.getObjectHandle(\'RR2\')\n    Slide_rail3= sim.getObjectHandle(\'R3\')\n    Roller3= sim.getObjectHandle(\'RR3\')\n    Slide_rail4= sim.getObjectHandle(\'R4\')\n    Roller4= sim.getObjectHandle(\'RR4\')\n    Slide_rail_v=0\n    Roller_v=0\n    Roller_v2=0\n    Roller_v3=0\n    Roller_v4=0\n    dVel=0.5\n    --computer--\n    Body=sim.getObjectHandle(\'LSO1\')\n    Body2=sim.getObjectHandle(\'LSO2\')\n    Body3=sim.getObjectHandle(\'LSO3\')\n    Body4=sim.getObjectHandle(\'LSO4\')\n--  test=sim.getObjectHandle(\'LS3_P1\')\n    LR1=sim.getObjectHandle(\'LR1\')  \n    LR2=sim.getObjectHandle(\'LR2\')\n    LR3=sim.getObjectHandle(\'LL3\')\n    LR4=sim.getObjectHandle(\'LR4\')\n    L1=sim.getObjectHandle(\'L1\')\n    L2=sim.getObjectHandle(\'L2\')\n    L3=sim.getObjectHandle(\'L3\')\n    L4=sim.getObjectHandle(\'L4\')\n    --goal--\n    Player_G = 0\n    Computer_G = 0\nend\n\nfunction sysCall_actuation()\n    --player--\n    A= sim.getObjectHandle(\'RS1_PO1\') --auto_return--1\n    PA= sim.getObjectPosition(A,-1)\n    if PA[1] >= -0.712 then\n        Roller_v = Roller_v + dVel*3\n    end\n    B= sim.getObjectHandle(\'RS2_PO1\') --auto_return--2\n    PB= sim.getObjectPosition(B,-1)\n    if PB[1] >= -0.531 then\n        Roller_v2 = Roller_v2 + dVel*3\n    end\n    C= sim.getObjectHandle(\'RS4_PO2\') --auto_return--3\n    PC= sim.getObjectPosition(C,-1)\n    if PC[1] >= -0.197 then\n        Roller_v3=Roller_v3 + dVel*5\n    end\n    D= sim.getObjectHandle(\'RS3_PO1\') --auto_return--4\n    PD= sim.getObjectPosition(D,-1)\n    if PD[1] >= 0.137 then\n        Roller_v4=Roller_v4 + dVel*5\n    end\n\n    message,auxiliaryData=sim.getSimulatorMessage()\n    while message~=-1 do\n        if (message==sim.message_keypress) then   \n            if (auxiliaryData[1]==32) then   --"space"--restart\n              sim.setObjectPosition(Ball,-1,{-0.1429, -0.1334, 0.5})\n            end\n            if (auxiliaryData[1]==122) then  --"z"--goalkeeper\n               Roller_v = Roller_v - dVel*50\n               if (Roller_v > 0) then\n                  Roller_v = 0\n               end\n            end\n            if (auxiliaryData[1]==120) then   --"x"--2\n               Roller_v2 = Roller_v2 - dVel*30\n               if (Roller_v2 > 0) then\n                  Roller_v2 = 0\n               end\n            end\n            if (auxiliaryData[1]==99) then  --"c"--3\n               Roller_v3 = Roller_v3 - dVel*30\n               if (Roller_v3 > 0) then\n                  Roller_v3 = 0\n               end\n            end\n            if (auxiliaryData[1]==118) then  --"v"--4\n               Roller_v4 = Roller_v4 - dVel*30\n               if (Roller_v4 > 0) then\n                  Roller_v4 = 0\n               end\n            end\n            if (auxiliaryData[1]==2008) then --"down"--return_player\n                Roller_v = Roller_v + dVel*20\n                Roller_v2 = Roller_v2 + dVel*20\n                Roller_v3 = Roller_v3 + dVel*20\n                Roller_v4 = Roller_v4 + dVel*20\n               if (Roller_v < 0) then\n                  Roller_v = 0\n               end\n               if (Roller_v2 < 0) then\n                  Roller_v2 = 0\n               end\n               if (Roller_v3 < 0) then\n                  Roller_v3 = 0\n               end\n               if (Roller_v4 < 0) then\n                  Roller_v4 = 0\n               end\n            end\n            if (auxiliaryData[1]==2009) then --"right"\n               Slide_rail_v = Slide_rail_v + dVel/5\n               if (Slide_rail_v < 0) then\n                  Slide_rail_v = 0\n               end\n            end\n            if (auxiliaryData[1]==2010) then --"left"\n                Slide_rail_v = Slide_rail_v - dVel/5\n                if (Slide_rail_v > 0) then\n                  Slide_rail_v = 0\n                end\n            end\n        end\n        message,auxiliaryData=sim.getSimulatorMessage()\n    end\n    Slide_rail_v2 = Slide_rail_v/1.3\n    Slide_rail_v3 = Slide_rail_v/1.5\n    Slide_rail_v4 = Slide_rail_v/1.4\n    sim.setJointTargetVelocity(Slide_rail,Slide_rail_v)\n    sim.setJointTargetVelocity(Roller,Roller_v)\n    sim.setJointTargetVelocity(Slide_rail2,Slide_rail_v2)\n    sim.setJointTargetVelocity(Roller2,Roller_v2)\n    sim.setJointTargetVelocity(Slide_rail3,Slide_rail_v3)\n    sim.setJointTargetVelocity(Roller3,Roller_v4)\n    sim.setJointTargetVelocity(Slide_rail4,Slide_rail_v4)\n    sim.setJointTargetVelocity(Roller4,Roller_v3)\n    --computer--\n    Body_s = sim.getObjectPosition(Body,-1)\n    Ball_s = sim.getObjectPosition(Ball,-1)\n    X = Body_s[1] - Ball_s[1]\n    Y = Body_s[2] - Ball_s[2]\n    if 1 then  --C_goalkeeper\n        if X <= 0.02 then\n            sim.setJointTargetVelocity(LR1,-5)\n            sim.setJointTargetVelocity(L1,0)\n        elseif X > 0.02 or X <= 0.01 then\n            sim.setJointTargetVelocity(LR1,5)\n            YYYYY = Y*7\n            sim.setJointTargetVelocity(L1,YYYYY)\n        end\n--[[    if X <= 0.02 and Y <= 0 then   --old_version\n            sim.setJointTargetVelocity(LR1,-5)\n        elseif X > 0.02 and Y <= 0 then\n            sim.setJointTargetVelocity(LR1,2)\n        elseif X <= 0.02 and Y > 0 then          40623130  \n            sim.setJointTargetVelocity(LR1,-5)        \n        elseif X > 0.02 and Y > 0 then                \n            sim.setJointTargetVelocity(LR1,2)\n        end]]\n    end\n\n    Body_s2 = sim.getObjectPosition(Body2,-1)\n    X2_1 = Body_s2[1] - Ball_s[1]\n    Y2_1 = Body_s2[2] - Ball_s[2] - 0.15\n    Y2_2 = Body_s2[2] - Ball_s[2] + 0.15\n    if X2_1 >= 0.02 then --C_second--\n        if Ball_s[2] <= -0.133 then\n            C_K_B_X2()\n        Y2_1 = Y2_1*5\n        sim.setJointTargetVelocity(L2,Y2_1)\n        elseif Ball_s[2] > -0.133 then\n            C_K_B_X2()\n        Y2_2 = Y2_2*5\n        sim.setJointTargetVelocity(L2,Y2_2)\n        end\n    end\n\n    Body_s4 = sim.getObjectPosition(Body4,-1)\n    X4_1 = Body_s4[1] - Ball_s[1]\n    Y4_1 = Body_s4[2] - Ball_s[2] - 0.15\n    Y4_2 = Body_s4[2] - Ball_s[2] + 0.15\n    if X4_1 >= 0.02 then --C_third--\n        if Ball_s[2] <= -0.133 then\n            C_K_B_X4()\n        Y4_1 = Y4_1*3\n        sim.setJointTargetVelocity(L4,Y4_1)\n        elseif Ball_s[2] > -0.133 then\n            C_K_B_X4()\n        Y4_2 = Y4_2*3\n        sim.setJointTargetVelocity(L4,Y4_2)\n        end\n    end\n--[[\n    test_s = sim.getObjectPosition(test,-1)\n    M =  test_s[2]- Ball_s[2]\n    print(M)\n--]]\n    Body_s3 = sim.getObjectPosition(Body3,-1)\n    X3_1 = Body_s3[1] - Ball_s[1]\n    Y3_1 = Body_s3[2] - Ball_s[2]\n    Y3_2 = Body_s3[2] - Ball_s[2] +0.2487\n    Y3_3 = Body_s3[2] - Ball_s[2] -0.2487\n    if X3_1 >= 0.02 then --C_fourth--\n        if Ball_s[2] < -0.0028 and Ball_s[2] >= -0.2487 then\n            C_K_B_X3()\n        Y3_1 = Y3_1*2\n        sim.setJointTargetVelocity(L3,Y3_1)\n        elseif Ball_s[2] >= -0.0028 then\n            C_K_B_X3()\n        Y3_2 = Y3_2*2\n        sim.setJointTargetVelocity(L3,Y3_2)\n        elseif Ball_s[2] < -0.2487 then\n            C_K_B_X3()\n        Y3_3 = Y3_3*2\n        sim.setJointTargetVelocity(L3,Y3_3)\n        end\n    end\n    --reborn_ball & count goal--\n    if Ball_s[1] < -0.85 then\n        Player_G = Player_G + 1\n    end    \n    if Ball_s[1] >= 0.61 then\n        Computer_G = Computer_G+1\n    end\n    if Ball_s[1] < -0.85 or Ball_s[1] >= 0.61 then\n        sim.setObjectPosition(Ball,-1,{-0.1429, -0.1334, 0.5})\n        print[[Player:Computer]]\n        print(\'      \'..Computer_G..\'     \'..Player_G)\n    end\nend\nfunction C_K_B_X2() --C_second_kick--\n    if X2_1 < 0.03 then\n    sim.setJointTargetVelocity(LR2,-5)\n    elseif X2_1 > 0.03 then\n    sim.setJointTargetVelocity(LR2,5)\n    end\nend\nfunction C_K_B_X3() --C_third_kcik--\n    if X3_1 < 0.03 then\n    sim.setJointTargetVelocity(LR3,-5)\n    elseif X3_1 > 0.03 then\n    sim.setJointTargetVelocity(LR3,5)\n    end\nend\nfunction C_K_B_X4() --C_fourth_kick--\n    if X4_1 < 0.03 then\n    sim.setJointTargetVelocity(LR4,-5)\n    elseif X4_1 > 0.03 then\n    sim.setJointTargetVelocity(LR4,5)\n    end\nend \n', 'tags': '', 'url': '第十五周.html'}]};