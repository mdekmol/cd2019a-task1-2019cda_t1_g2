<!doctype html>
<html><head>
<meta http-equiv="content-type" content="text/html;charset=utf-8">
<title>2019cda_t1_g2</title> <link rel="stylesheet" type="text/css" href="./../static/cmsimply.css">
<script src="tipuesearch_content.js"></script>
<script src="./../static/jquery.js"></script>
<link rel="stylesheet" href="./../static/tipuesearch/css/tipuesearch.css">
<script src="./../static/tipuesearch/tipuesearch_set.js"></script>
<script src="./../static/tipuesearch/tipuesearch.min.js"></script>

<script type="text/javascript" src="./../static/syntaxhighlighter/shCore.js"></script>
<script type="text/javascript" src="./../static/syntaxhighlighter/shBrushJScript.js"></script>
<script type="text/javascript" src="./../static/syntaxhighlighter/shBrushJava.js"></script>
<script type="text/javascript" src="./../static/syntaxhighlighter/shBrushPython.js"></script>
<script type="text/javascript" src="./../static/syntaxhighlighter/shBrushSql.js"></script>
<script type="text/javascript" src="./../static/syntaxhighlighter/shBrushXml.js"></script>
<script type="text/javascript" src="./../static/syntaxhighlighter/shBrushPhp.js"></script>
<script type="text/javascript" src="./../static/syntaxhighlighter/shBrushLua.js"></script>
<script type="text/javascript" src="./../static/syntaxhighlighter/shBrushCpp.js"></script>
<script type="text/javascript" src="./../static/syntaxhighlighter/shBrushCss.js"></script>
<script type="text/javascript" src="./../static/syntaxhighlighter/shBrushCSharp.js"></script>
<link type="text/css" rel="stylesheet" href="./../static/syntaxhighlighter/css/shCoreDefault.css"/>
<script type="text/javascript">SyntaxHighlighter.all();</script>

<!-- for LaTeX equations 暫時不用
<script src="https://scrum-3.github.io/web/math/MathJax.js?config=TeX-MML-AM_CHTML" type="text/javascript"></script>
<script type="text/javascript">
init_mathjax = function() {
    if (window.MathJax) {
        // MathJax loaded
        MathJax.Hub.Config({
            tex2jax: {
                inlineMath: [ ['$','$'], ["\\(","\\)"] ],
                displayMath: [ ['$$','$$'], ["\\[","\\]"] ]
            },
            displayAlign: 'left', // Change this to 'center' to center equations.
            "HTML-CSS": {
                styles: {'.MathJax_Display': {"margin": 0}}
            }
        });
        MathJax.Hub.Queue(["Typeset",MathJax.Hub]);
    }
}
init_mathjax();
</script>
-->
<!-- 暫時不用
<script src="./../static/fengari-web.js"></script>
<script type="text/javascript" src="./../static/Cango-13v08-min.js"></script>
<script type="text/javascript" src="./../static/CangoAxes-4v01-min.js"></script>
<script type="text/javascript" src="./../static/gearUtils-05.js"></script>
-->
<!-- for Brython 暫時不用
<script src="https://scrum-3.github.io/web/brython/brython.js"></script>
<script src="https://scrum-3.github.io/web/brython/brython_stdlib.js"></script>
-->

<script type="text/javascript">
/*shorthand of $(document).ready(function(){};); */
$(function(){
    $("ul.topmenu> li:has(ul) > a").append('<div class="arrow-right"></div>');
    $("ul.topmenu > li ul li:has(ul) > a").append('<div class="arrow-right"></div>');
});
function doSearch() {
     $('#tipue_search_input').tipuesearch({
        newWindow: true, minimumLength: 2
     });
}
$(document).ready(doSearch);
</script>

</head><header><h1>產品協同設計第二組</h1> <confmenu>
<ul>
<li><a href="index.html">Home</a></li>
<li><a href="sitemap.html">Site Map</a></li>
<li><a href="./../reveal/index.html">reveal</a></li>
<li><a href="https://cda2019g2.blogspot.com/">blog</a></li>

</ul>
</confmenu></header>
<div class='container'><nav><ul id='css3menu1' class='topmenu'><div class="tipue_search_group"><input style="width: 6vw;" type="text" name="q" id="tipue_search_input" pattern=".{2,}" title="Press enter key to search" required></div><li><a href='簡介.html'>簡介</a><ul><li><a href='組員名單與網站.html'>組員名單與網站</a></li></ul><li><a href='執行規劃.html'>執行規劃</a><ul><li><a href='手足球系統模擬.html'>手足球系統模擬</a></li></ul><li><a href='設計與繪圖.html'>設計與繪圖</a><ul><li><a href='零組件尺寸分析.html'>零組件尺寸分析</a><li><a href='參數設計與繪圖.html'>參數設計與繪圖</a><li><a href='細部設計與 BOM.html'>細部設計與 BOM</a></li></ul><li><a href='V-rep 動態模擬.html'>V-rep 動態模擬</a><ul><li><a href='送球機構設計與模擬.html'>送球機構設計與模擬</a><li><a href='系統功能展示.html'>系統功能展示</a></li></ul><li><a href='結案報告.html'>結案報告</a><ul><li><a href='專案口頭簡報.html'>專案口頭簡報</a><li><a href='專案報告書.html'>專案報告書</a><li><a href='如何開始編輯報告書.html'>如何開始編輯報告書</a></li></ul><li><a href='第十周前.html'>第十周前</a><ul><li><a href='Task-1.html'>Task-1</a><ul><li><a href='自定義隨身系統.html'>自定義隨身系統</a><li><a href='隨機分組介面成品.html'>隨機分組介面成品</a><li><a href='分組程式修正.html'>分組程式修正</a><li><a href='ungit使用手冊.html'>ungit使用手冊</a><li><a href='問題.html'>問題</a></li></ul><li><a href='Task-2.html'>Task-2</a><ul><li><a href='Vrep.html'>Vrep</a><li><a href='Vrep-2.html'>Vrep-2</a><li><a href='Onshape.html'>Onshape</a><li><a href='Extra-add.html'>Extra-add</a><li><a href='Final-handball.html'>Final-handball</a></li></ul><li><a href='期中報告.html'>期中報告</a><li><a href='Virtualbox虛擬主機網路設定.html'>Virtualbox虛擬主機網路設定</a><li><a href='換行code 改寫.html'>換行code 改寫</a><li><a href='圖形簡化.html'>圖形簡化</a></li></ul><li><a href='第十一周.html'>第十一周</a><li><a href='第十二周.html'>第十二周</a><li><a href='第十三周.html'>第十三周</a><ul><li><a href='V-rep簡化.html'>V-rep簡化</a></li></ul><li><a href='第十四周-簡化.html'>第十四周-簡化</a><ul><li><a href='編輯報告書.html'>編輯報告書</a></li></ul><li><a href='第十五周.html'>第十五周</a></li></ul></nav><section><div id="tipue_search_content">送球機構設計與模擬 << <a href='送球機構設計與模擬.html'>Previous</a> <a href='結案報告.html'>Next</a> >> 結案報告<br /><h1>系統功能展示</h1>
<p><a href="https://mdecadp2018.github.io/site-40623130/content/Vrep%E6%89%8B%E8%B6%B3%E7%90%83-All_Version.html">這裡紀載了全部的手足球版本以及詳細歷程</a></p>
<h4>人機對決</h4>
<p>最終版本的'玩家與電腦'對打，完整code</p>
<p>操作說明:方向鍵的左右下按鍵 、z、x、c、v分別按順序從z的守門員到v的最前排、R鍵用來讓球回位至正中央(怕卡bug)</p>
<p><img alt="" height="564" src="./../images/FTB(final).gif" width="1000"/></p>
<pre class="brush:lua;auto-links:false;toolbar:false" contenteditable="false">function sysCall_init()
    Ball=sim.getObjectHandle('ball')
    --player--
    Slide_rail= sim.getObjectHandle('R1')
    Roller= sim.getObjectHandle('RR1')
    Slide_rail2= sim.getObjectHandle('R2')
    Roller2= sim.getObjectHandle('RR2')
    Slide_rail3= sim.getObjectHandle('R3')
    Roller3= sim.getObjectHandle('RR3')
    Slide_rail4= sim.getObjectHandle('R4')
    Roller4= sim.getObjectHandle('RR4')
    Slide_rail_v=0
    Roller_v=0
    Roller_v2=0
    Roller_v3=0
    Roller_v4=0
    dVel=0.5
    --computer--
    Body=sim.getObjectHandle('LSO1')
    Body2=sim.getObjectHandle('LSO2')
    Body3=sim.getObjectHandle('LSO3')
    Body4=sim.getObjectHandle('LSO4')
    LR1=sim.getObjectHandle('LR1')  
    LR2=sim.getObjectHandle('LR2')
    LR3=sim.getObjectHandle('LL3')
    LR4=sim.getObjectHandle('LR4')
    L1=sim.getObjectHandle('L1')
    L2=sim.getObjectHandle('L2')
    L3=sim.getObjectHandle('L3')
    L4=sim.getObjectHandle('L4')
    --goal--
    Player_G = 0
    Computer_G = 0
    --reball--
    Push_1=sim.getObjectHandle('Push_1')
    Push_2=sim.getObjectHandle('Push_2')
end

function sysCall_actuation()
    --player--
    A= sim.getObjectHandle('RS1_PO1') --auto_return--1
    PA= sim.getObjectPosition(A,-1)
    if PA[1] &gt;= -0.712 then
        Roller_v = Roller_v + dVel*2.5
    end
    B= sim.getObjectHandle('RS2_PO1') --auto_return--2
    PB= sim.getObjectPosition(B,-1)
    if PB[1] &gt;= -0.531 then
        Roller_v2 = Roller_v2 + dVel*5
    end
    C= sim.getObjectHandle('RS4_PO2') --auto_return--3
    PC= sim.getObjectPosition(C,-1)
    if PC[1] &gt;= -0.197 then
        Roller_v3=Roller_v3 + dVel*5
    end
    D= sim.getObjectHandle('RS3_PO1') --auto_return--4
    PD= sim.getObjectPosition(D,-1)
    if PD[1] &gt;= 0.137 then
        Roller_v4=Roller_v4 + dVel*5
    end

    message,auxiliaryData=sim.getSimulatorMessage()
    while message~=-1 do
        if (message==sim.message_keypress) then   
            if (auxiliaryData[1]==114) then   --"r"--restart
              sim.setObjectPosition(Ball,-1,{-0.15, -0.1334, 0.5})
            end
            if (auxiliaryData[1]==122) then  --"z"--goalkeeper
               Roller_v = Roller_v - dVel*60
               if (Roller_v &gt; 0) then
                  Roller_v = 0
               end
            end
            if (auxiliaryData[1]==120) then   --"x"--2
               Roller_v2 = Roller_v2 - dVel*15
               if (Roller_v2 &gt; 0) then
                  Roller_v2 = 0
               end
            end
            if (auxiliaryData[1]==99) then  --"c"--3
               Roller_v3 = Roller_v3 - dVel*15
               if (Roller_v3 &gt; 0) then
                  Roller_v3 = 0
               end
            end
            if (auxiliaryData[1]==118) then  --"v"--4
               Roller_v4 = Roller_v4 - dVel*15
               if (Roller_v4 &gt; 0) then
                  Roller_v4 = 0
               end
            end
            if (auxiliaryData[1]==2008) then --"down"--return_player
                Roller_v = Roller_v + dVel*20
                Roller_v2 = Roller_v2 + dVel*20
                Roller_v3 = Roller_v3 + dVel*20
                Roller_v4 = Roller_v4 + dVel*20
               if (Roller_v &lt; 0) then
                  Roller_v = 0
               end
               if (Roller_v2 &lt; 0) then
                  Roller_v2 = 0
               end
               if (Roller_v3 &lt; 0) then
                  Roller_v3 = 0
               end
               if (Roller_v4 &lt; 0) then
                  Roller_v4 = 0
               end
            end
            if (auxiliaryData[1]==2009) then --"right"
               Slide_rail_v = Slide_rail_v + dVel/5
               if (Slide_rail_v &lt; 0) then
                  Slide_rail_v = 0
               end
            end
            if (auxiliaryData[1]==2010) then --"left"
                Slide_rail_v = Slide_rail_v - dVel/5
                if (Slide_rail_v &gt; 0) then
                  Slide_rail_v = 0
                end
            end
        end
        message,auxiliaryData=sim.getSimulatorMessage()
    end
    Slide_rail_v2 = Slide_rail_v/1.3
    Slide_rail_v3 = Slide_rail_v/1.5
    Slide_rail_v4 = Slide_rail_v/1.4
    sim.setJointTargetVelocity(Slide_rail,Slide_rail_v)
    sim.setJointTargetVelocity(Roller,Roller_v)
    sim.setJointTargetVelocity(Slide_rail2,Slide_rail_v2)
    sim.setJointTargetVelocity(Roller2,Roller_v2)
    sim.setJointTargetVelocity(Slide_rail3,Slide_rail_v3)
    sim.setJointTargetVelocity(Roller3,Roller_v4)
    sim.setJointTargetVelocity(Slide_rail4,Slide_rail_v4)
    sim.setJointTargetVelocity(Roller4,Roller_v3)
    --computer--
    Body_s = sim.getObjectPosition(Body,-1)
    Ball_s = sim.getObjectPosition(Ball,-1)
    X = Body_s[1] - Ball_s[1]
    Y = Body_s[2] - Ball_s[2]
    if 1 then  --C_goalkeeper
        if X &lt;= 0.02 then
            sim.setJointTargetVelocity(LR1,-5)
            sim.setJointTargetVelocity(L1,0)
        elseif X &gt; 0.02 or X &lt;= 0.01 then
            sim.setJointTargetVelocity(LR1,5)
            YYYYY = Y*7
            sim.setJointTargetVelocity(L1,YYYYY)
        end
    end

    Body_s2 = sim.getObjectPosition(Body2,-1)
    X2_1 = Body_s2[1] - Ball_s[1]
    Y2_1 = Body_s2[2] - Ball_s[2] - 0.15
    Y2_2 = Body_s2[2] - Ball_s[2] + 0.15
    if X2_1 &gt;= 0.01 then --C_second--
        if Ball_s[2] &lt;= -0.133 then
            C_K_B_X2()
        Y2_1 = Y2_1*5
        sim.setJointTargetVelocity(L2,Y2_1)
        elseif Ball_s[2] &gt; -0.133 then
            C_K_B_X2()
        Y2_2 = Y2_2*5
        sim.setJointTargetVelocity(L2,Y2_2)
        end
    end

    Body_s4 = sim.getObjectPosition(Body4,-1)
    X4_1 = Body_s4[1] - Ball_s[1]
    Y4_1 = Body_s4[2] - Ball_s[2] - 0.15
    Y4_2 = Body_s4[2] - Ball_s[2] + 0.15
    if X4_1 &gt;= 0.01 then --C_third--
        if Ball_s[2] &lt;= -0.133 then
            C_K_B_X4()
        Y4_1 = Y4_1*3
        sim.setJointTargetVelocity(L4,Y4_1)
        elseif Ball_s[2] &gt; -0.133 then
            C_K_B_X4()
        Y4_2 = Y4_2*3
        sim.setJointTargetVelocity(L4,Y4_2)
        end
    end

    Body_s3 = sim.getObjectPosition(Body3,-1)
    X3_1 = Body_s3[1] - Ball_s[1]
    Y3_1 = Body_s3[2] - Ball_s[2]
    Y3_2 = Body_s3[2] - Ball_s[2] +0.2487
    Y3_3 = Body_s3[2] - Ball_s[2] -0.2487
    if X3_1 &gt;= 0.01 then --C_fourth--
        if Ball_s[2] &lt; -0.0028 and Ball_s[2] &gt;= -0.2487 then
            C_K_B_X3()
        Y3_1 = Y3_1*2.5
        sim.setJointTargetVelocity(L3,Y3_1)
        elseif Ball_s[2] &gt;= -0.0028 then
            C_K_B_X3()
        Y3_2 = Y3_2*2.5
        sim.setJointTargetVelocity(L3,Y3_2)
        elseif Ball_s[2] &lt; -0.2487 then
            C_K_B_X3()
        Y3_3 = Y3_3*2.5
        sim.setJointTargetVelocity(L3,Y3_3)
        end
    end
    --reborn_ball &amp; count goal--
    reborn_ball_count_goal()
end
function C_K_B_X2() --C_second_kick--
    if X2_1 &lt; 0.06 then
    sim.setJointTargetVelocity(LR2,-5)
    elseif X2_1 &gt; 0.03 then
    sim.setJointTargetVelocity(LR2,5)
    end
end
function C_K_B_X3() --C_third_kcik--
    if X3_1 &lt; 0.06 then
    sim.setJointTargetVelocity(LR3,-5)
    elseif X3_1 &gt; 0.03 then
    sim.setJointTargetVelocity(LR3,5)
    end
end
function C_K_B_X4() --C_fourth_kick--
    if X4_1 &lt; 0.06 then
    sim.setJointTargetVelocity(LR4,-5)
    elseif X4_1 &gt; 0.03 then
    sim.setJointTargetVelocity(LR4,5)
    end
end
function reborn_ball_count_goal()
    if Ball_s[1] &lt; -0.85 and Ball_s[1] &gt; -0.87 then
        Player_G = Player_G + 1
    end    
    if Ball_s[1] &gt; 0.61 and Ball_s[1] &lt; 0.62 then
        Computer_G = Computer_G + 1
    end
    if Ball_s[1] &lt; -0.85 or Ball_s[1] &gt; 0.61 then
        print[[Player : Computer]]
        print('      '..Computer_G..'     '..Player_G)
    end

    if Ball_s[1] &gt; 0.905 and Ball_s[2] &lt; -0.069 and Ball_s[3] &lt; 0.036 then
        sim.setJointTargetVelocity(Push_1,1)
    elseif Ball_s[3] &gt; 0.036 then
        sim.setJointTargetVelocity(Push_1,-1)
    end
    if Ball_s[1] &lt; -1.15 and Ball_s[2] &lt; -0.123 and Ball_s[3] &lt; 0.036 then
        sim.setJointTargetVelocity(Push_2,-1)
    elseif Ball_s[3] &gt; 0.036 then
        sim.setJointTargetVelocity(Push_2,1)
    end

    if Ball_s[1] &lt; -1.156 and Ball_s[2] &gt; 0.163 and Ball_s[3] &gt; 0.058 then
    sim.setObjectPosition(Ball,-1,{-0.20361, 0.2739, 0.15735})
    end
    if Ball_s[1] &lt; -0.20361 and Ball_s[2] &gt; 0.2740 and Ball_s[3] &gt; 0.15735 then
    sim.setObjectPosition(Ball,-1,{-0.2049, 0.23, 0.1482})
    end
    if Ball_s[1] &gt; 0.9056 and Ball_s[2] &lt;  -0.4247 and Ball_s[3] &gt; 0.0592 then
    sim.setObjectPosition(Ball,-1,{-0.043425,  -0.60401, 0.15735})
    end
    if Ball_s[1] &gt; -0.04753 and Ball_s[2] &lt;  -0.5240 and Ball_s[3] &gt; 0.15735 then
    sim.setObjectPosition(Ball,-1,{-0.03667,  -0.48443, 0.1482})
    end
end</pre>
<h4><iframe allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen="allowfullscreen" frameborder="0" height="315" src="//www.youtube.com/embed/v7auUIJMlGg" width="560"></iframe></h4>
<p>檔案:<a href="https://github.com/mdecadp2018/site-40623130/blob/gh-pages/v-rep/robot/FinalVersion.ttt">https://github.com/mdecadp2018/site-40623130/blob/gh-pages/v-rep/robot/FinalVersion.ttt</a></p>
<h4>機²<span>對決</span></h4>
<p><span>寫完人機對打後，花了不到1小時寫完電腦對電腦的版本</span></p>
<p><img alt="" height="564" src="./../images/FTB(final_EX).gif" width="1000"/></p>
<pre class="brush:lua;auto-links:false;toolbar:false" contenteditable="false">function sysCall_init()
    Ball=sim.getObjectHandle('ball')
    --computer--
    Body=sim.getObjectHandle('LSO1')
    Body2=sim.getObjectHandle('LSO2')
    Body3=sim.getObjectHandle('LSO3')
    Body4=sim.getObjectHandle('LSO4')
    LR1=sim.getObjectHandle('LR1')  
    LR2=sim.getObjectHandle('LR2')
    LR3=sim.getObjectHandle('LL3')
    LR4=sim.getObjectHandle('LR4')
    L1=sim.getObjectHandle('L1')
    L2=sim.getObjectHandle('L2')
    L3=sim.getObjectHandle('L3')
    L4=sim.getObjectHandle('L4')
    --computer2--
    Body_2=sim.getObjectHandle('RSO1')
    Body2_2=sim.getObjectHandle('RSO2')
    Body3_2=sim.getObjectHandle('RSO3')
    Body4_2=sim.getObjectHandle('RSO4')
    RR1=sim.getObjectHandle('RR1')  
    RR2=sim.getObjectHandle('RR2')
    RR3=sim.getObjectHandle('RR3')
    RR4=sim.getObjectHandle('RR4')
    R1=sim.getObjectHandle('R1')
    R2=sim.getObjectHandle('R2')
    R3=sim.getObjectHandle('R3')
    R4=sim.getObjectHandle('R4')
    --goal--
    Player_G = 0
    Computer_G = 0
    --reball--
    Push_1=sim.getObjectHandle('Push_1')
    Push_2=sim.getObjectHandle('Push_2')
end
 
function sysCall_actuation()
    message,auxiliaryData=sim.getSimulatorMessage()
    while message~=-1 do
        if (message==sim.message_keypress) then  
            if (auxiliaryData[1]==114) then   --"r"--restart
              sim.setObjectPosition(Ball,-1,{-0.15, -0.1334, 0.5})
            end
        end
        message,auxiliaryData=sim.getSimulatorMessage()
    end
    --computer--
    Body_s = sim.getObjectPosition(Body,-1)
    Ball_s = sim.getObjectPosition(Ball,-1)
    X = Body_s[1] - Ball_s[1]
    Y = Body_s[2] - Ball_s[2]
    if 1 then  --C_goalkeeper
        if X &lt;= 0.02 then
            sim.setJointTargetVelocity(LR1,-5)
            sim.setJointTargetVelocity(L1,0)
        elseif X &gt; 0.02 or X &lt;= 0.01 then
            sim.setJointTargetVelocity(LR1,5)
            YYYYY = Y*7
            sim.setJointTargetVelocity(L1,YYYYY)
        end
    end
 
    Body_s2 = sim.getObjectPosition(Body2,-1)
    X2_1 = Body_s2[1] - Ball_s[1]
    Y2_1 = Body_s2[2] - Ball_s[2] - 0.15
    Y2_2 = Body_s2[2] - Ball_s[2] + 0.15
    if X2_1 &gt;= 0.01 then --C_second--
        if Ball_s[2] &lt;= -0.133 then
            C_K_B_X2()
        Y2_1 = Y2_1*5
        sim.setJointTargetVelocity(L2,Y2_1)
        elseif Ball_s[2] &gt; -0.133 then
            C_K_B_X2()
        Y2_2 = Y2_2*5
        sim.setJointTargetVelocity(L2,Y2_2)
        end
    end
 
    Body_s4 = sim.getObjectPosition(Body4,-1)
    X4_1 = Body_s4[1] - Ball_s[1]
    Y4_1 = Body_s4[2] - Ball_s[2] - 0.15
    Y4_2 = Body_s4[2] - Ball_s[2] + 0.15
    if X4_1 &gt;= 0.01 then --C_third--
        if Ball_s[2] &lt;= -0.133 then
            C_K_B_X4()
        Y4_1 = Y4_1*3
        sim.setJointTargetVelocity(L4,Y4_1)
        elseif Ball_s[2] &gt; -0.133 then
            C_K_B_X4()
        Y4_2 = Y4_2*3
        sim.setJointTargetVelocity(L4,Y4_2)
        end
    end
 
    Body_s3 = sim.getObjectPosition(Body3,-1)
    X3_1 = Body_s3[1] - Ball_s[1]
    Y3_1 = Body_s3[2] - Ball_s[2]
    Y3_2 = Body_s3[2] - Ball_s[2] +0.2487
    Y3_3 = Body_s3[2] - Ball_s[2] -0.2487
    if X3_1 &gt;= 0.01 then --C_fourth--
        if Ball_s[2] &lt; -0.0028 and Ball_s[2] &gt;= -0.2487 then
            C_K_B_X3()
        Y3_1 = Y3_1*2.5
        sim.setJointTargetVelocity(L3,Y3_1)
        elseif Ball_s[2] &gt;= -0.0028 then
            C_K_B_X3()
        Y3_2 = Y3_2*2.5
        sim.setJointTargetVelocity(L3,Y3_2)
        elseif Ball_s[2] &lt; -0.2487 then
            C_K_B_X3()
        Y3_3 = Y3_3*2.5
        sim.setJointTargetVelocity(L3,Y3_3)
        end
    end
    --computer2--
    Body_2_s = sim.getObjectPosition(Body_2,-1)
    X_2 = Body_2_s[1] - Ball_s[1]
    Y_2 = Body_2_s[2] - Ball_s[2]
    if 1 then  --C_goalkeeper
        if X_2 &gt; -0.02 then
            sim.setJointTargetVelocity(RR1,-5)
            sim.setJointTargetVelocity(R1,0)
            Y_2 = 0
        elseif X_2 &lt; -0.02 or X_2 &gt; -0.01 then
            sim.setJointTargetVelocity(RR1,5)
            YYYYY_2 = Y_2*-7
            sim.setJointTargetVelocity(R1,YYYYY_2)
        end
    end
 
    Body_2_s2 = sim.getObjectPosition(Body2_2,-1)
    X2_1_2 = Body_2_s2[1] - Ball_s[1]
    Y2_1_2 = Body_2_s2[2] - Ball_s[2] - 0.15
    Y2_2_2 = Body_2_s2[2] - Ball_s[2] + 0.15
    if X2_1_2 &lt; -0.01 then --C_second--
        if Ball_s[2] &lt;= -0.133 then
            C_K_B_X2_2()
        Y2_1_2 = Y2_1_2*-5
        sim.setJointTargetVelocity(R2,Y2_1_2)
        elseif Ball_s[2] &gt; -0.133 then
            C_K_B_X2_2()
        Y2_2_2 = Y2_2_2*-5
        sim.setJointTargetVelocity(R2,Y2_2_2)
        end
    end
 
    Body_2_s4 = sim.getObjectPosition(Body4_2,-1)
    X4_1_2 = Body_2_s4[1] - Ball_s[1]
    Y4_1_2 = Body_2_s4[2] - Ball_s[2] - 0.15
    Y4_2_2 = Body_2_s4[2] - Ball_s[2] + 0.15
    if X4_1_2 &lt; -0.01 then --C_third--
        if Ball_s[2] &lt;= -0.133 then
            C_K_B_X4_2()
        Y4_1_2 = Y4_1_2*-3
        sim.setJointTargetVelocity(R4,Y4_1_2)
        elseif Ball_s[2] &gt; -0.133 then
            C_K_B_X4_2()
        Y4_2_2 = Y4_2_2*-3
        sim.setJointTargetVelocity(R4,Y4_2_2)
        end
    end
 
    Body_2_s3 = sim.getObjectPosition(Body3_2,-1)
    X3_1_2 = Body_2_s3[1] - Ball_s[1]
    Y3_1_2 = Body_2_s3[2] - Ball_s[2]
    Y3_2_2 = Body_2_s3[2] - Ball_s[2] +0.2487
    Y3_3_2 = Body_2_s3[2] - Ball_s[2] -0.2487
    if X3_1_2 &lt; 0.01 then --C_fourth--
        if Ball_s[2] &lt; -0.0028 and Ball_s[2] &gt;= -0.2487 then
            C_K_B_X3_2()
        Y3_1_2 = Y3_1_2*-2.5
        sim.setJointTargetVelocity(R3,Y3_1_2)
        elseif Ball_s[2] &gt;= -0.0028 then
            C_K_B_X3_2()
        Y3_2_2 = Y3_2_2*-2.5
        sim.setJointTargetVelocity(R3,Y3_2_2)
        elseif Ball_s[2] &lt; -0.2487 then
            C_K_B_X3_2()
        Y3_3_2 = Y3_3_2*-2.5
        sim.setJointTargetVelocity(R3,Y3_3_2)
        end
    end
    --reborn_ball &amp; count goal--
    reborn_ball_count_goal()
end
function C_K_B_X2() --C_second_kick--
    if X2_1 &lt; 0.06 then
    sim.setJointTargetVelocity(LR2,-5)
    elseif X2_1 &gt; 0.03 then
    sim.setJointTargetVelocity(LR2,5)
    end
end
function C_K_B_X3() --C_third_kcik--
    if X3_1 &lt; 0.06 then
    sim.setJointTargetVelocity(LR3,-5)
    elseif X3_1 &gt; 0.03 then
    sim.setJointTargetVelocity(LR3,5)
    end
end
function C_K_B_X4() --C_fourth_kick--
    if X4_1 &lt; 0.06 then
    sim.setJointTargetVelocity(LR4,-5)
    elseif X4_1 &gt; 0.03 then
    sim.setJointTargetVelocity(LR4,5)
    end
end
function C_K_B_X2_2() --C_2_second_kick--
    if X2_1_2 &lt; -0.03 then
    sim.setJointTargetVelocity(RR2,5)
    elseif X2_1_2 &gt; -0.03 then
    sim.setJointTargetVelocity(RR2,-5)
    end
end
function C_K_B_X3_2() --C_2_third_kcik--
    if X3_1_2 &lt; -0.03 then
    sim.setJointTargetVelocity(RR3,5)
    elseif X3_1_2 &gt; -0.03 then
    sim.setJointTargetVelocity(RR3,-5)
    end
end
function C_K_B_X4_2() --C_2_fourth_kick--
    if X4_1_2 &lt; -0.03 then
    sim.setJointTargetVelocity(RR4,5)
    elseif X4_1_2 &gt; -0.03 then
    sim.setJointTargetVelocity(RR4,-5)
    end
end
function reborn_ball_count_goal()
    if Ball_s[1] &lt; -0.85 and Ball_s[1] &gt; -0.87 then
        Player_G = Player_G + 1
    end   
    if Ball_s[1] &gt;= 0.61 and Ball_s[1] &lt; 0.63 then
        Computer_G = Computer_G + 1
    end
    if Ball_s[1] &lt; -0.85 or Ball_s[1] &gt;= 0.61 then
        print[[Player : Computer]]
        print('      '..Computer_G..'     '..Player_G)
    end
 
    if Ball_s[1] &gt; 0.905 and Ball_s[2] &lt; -0.069 and Ball_s[3] &lt; 0.036 then
        sim.setJointTargetVelocity(Push_1,1)
    elseif Ball_s[3] &gt; 0.036 then
        sim.setJointTargetVelocity(Push_1,-1)
    end
    if Ball_s[1] &lt; -1.15 and Ball_s[2] &lt; -0.123 and Ball_s[3] &lt; 0.036 then
        sim.setJointTargetVelocity(Push_2,-1)
    elseif Ball_s[3] &gt; 0.036 then
        sim.setJointTargetVelocity(Push_2,1)
    end
 
    if Ball_s[1] &lt; -1.156 and Ball_s[2] &gt; 0.163 and Ball_s[3] &gt; 0.058 then
    sim.setObjectPosition(Ball,-1,{-0.20361, 0.2739, 0.15735})
    end
    if Ball_s[1] &lt; -0.20361 and Ball_s[2] &gt; 0.2740 and Ball_s[3] &gt; 0.15735 then
    sim.setObjectPosition(Ball,-1,{-0.2049, 0.23, 0.1482})
    end
    if Ball_s[1] &gt; 0.9056 and Ball_s[2] &lt;  -0.4247 and Ball_s[3] &gt; 0.0592 then
    sim.setObjectPosition(Ball,-1,{-0.043425,  -0.60401, 0.15735})
    end
    if Ball_s[1] &gt; -0.04753 and Ball_s[2] &lt;  -0.5240 and Ball_s[3] &gt; 0.15735 then
    sim.setObjectPosition(Ball,-1,{-0.03667,  -0.48443, 0.1482})
    end
end</pre>
<p>檔案:<a href="https://github.com/mdecadp2018/site-40623130/blob/gh-pages/v-rep/robot/FinalVersion_EX.ttt">https://github.com/mdecadp2018/site-40623130/blob/gh-pages/v-rep/robot/FinalVersion_EX.ttt</a></p>
<h4><span>人形歸位</span></h4>
<p>我將每根桿件設定成"當按了按鍵變成擊球狀態後會到達邊界數值，如果到達邊界直做減速度運動回到初始狀態"，下方code中為+dVel，其原因是因為原先設定擊球為做減速度運動而回球則加入加速度。</p>
<p><img alt="" height="564" src="./../images/FTB(3).gif" width="1000"/></p>
<pre class="brush:lua;auto-links:false;toolbar:false" contenteditable="false">A= sim.getObjectHandle('RS1_PO1')
PA= sim.getObjectPosition(A,-1)
if PA[1] &gt;= -0.712 then
    Roller_v = Roller_v + dVel*3
end
B= sim.getObjectHandle('RS2_PO1')
PB= sim.getObjectPosition(B,-1)
if PB[1] &gt;= -0.531 then
    Roller_v2 = Roller_v2 + dVel*3
end
C= sim.getObjectHandle('RS4_PO2')
PC= sim.getObjectPosition(C,-1)
if PC[1] &gt;= -0.197 then
    Roller_v3=Roller_v3 + dVel*5
end
D= sim.getObjectHandle('RS3_PO1')
PD= sim.getObjectPosition(D,-1)
if PD[1] &gt;= 0.137 then
    Roller_v4=Roller_v4 + dVel*5
end</pre>
<p><span>檔案:<a href="https://github.com/mdecadp2018/site-40623130/blob/gh-pages/v-rep/robot/www2.ttt">https://github.com/mdecadp2018/site-40623130/blob/gh-pages/v-rep/robot/www2.ttt</a></span></p>
<h4>電腦多人形球位判斷式</h4>
<p>將擊球的人行分成三個後，紀錄每兩個人型之間的距離，利用補正讓球穿過人形與人形之間的分界線時，判斷式work，加入補正的數值讓最左或是最右邊的人形能對正球體。<span>此程式為最初簡易版本。</span></p>
<p><img alt="" height="564" src="./../images/FTB(6).gif" width="1000"/></p>
<p><span>以下都更改於function sysCall_actuation()中</span></p>
<pre class="brush:lua;auto-links:false;toolbar:false" contenteditable="false">-------------------------------------
               if (auxiliaryData[1]==2008) then
                Roller_v = Roller_v + dVel*20
                Roller_v2 = Roller_v2 + dVel*20
                Roller_v3 = Roller_v3 + dVel*20
                Roller_v4 = Roller_v4 + dVel*20
               if (Roller_v &lt; 0) then
                  Roller_v = 0
               end
               if (Roller_v2 &lt; 0) then
                  Roller_v2 = 0
               end
               if (Roller_v3 &lt; 0) then
                  Roller_v3 = 0
               end
               if (Roller_v4 &lt; 0) then
                  Roller_v4 = 0
               end
            end
-----------------------------------------------
    --computer--
    Body_s = sim.getObjectPosition(Body,-1)
    Ball_s = sim.getObjectPosition(Ball,-1)
    X = Body_s[1] - Ball_s[1]
    Y = Body_s[2] - Ball_s[2]
    if 1 then
        if X &lt;= 0.02 and Y &lt;= 0 then
            sim.setJointTargetVelocity(LR1,-5)
        elseif X &gt; 0.02 and Y &lt;= 0 then
            sim.setJointTargetVelocity(LR1,2)
        elseif X &lt;= 0.02 and Y &gt; 0 then            
            sim.setJointTargetVelocity(LR1,-5)        
        elseif X &gt; 0.02 and Y &gt; 0 then                
            sim.setJointTargetVelocity(LR1,2)
        end
        YYYYY = Y*7
        sim.setJointTargetVelocity(L1,YYYYY)
    end
 
    Body_s2 = sim.getObjectPosition(Body2,-1)
    X2_1 = Body_s2[1] - Ball_s[1]
    Y2_1 = Body_s2[2] - Ball_s[2] - 0.15
    Y2_2 = Body_s2[2] - Ball_s[2] + 0.15
    if X2_1 &gt;= 0.02 then
        if Ball_s[2] &lt;= -0.133 then
            C_K_B_X2()
        Y2_1 = Y2_1*5
        sim.setJointTargetVelocity(L2,Y2_1)
        elseif Ball_s[2] &gt; -0.133 then
            C_K_B_X2()
        Y2_2 = Y2_2*5
        sim.setJointTargetVelocity(L2,Y2_2)
        end
    end
 
    Body_s4 = sim.getObjectPosition(Body4,-1)
    X4_1 = Body_s4[1] - Ball_s[1]
    Y4_1 = Body_s4[2] - Ball_s[2] - 0.15
    Y4_2 = Body_s4[2] - Ball_s[2] + 0.15
    if X4_1 &gt;= 0.02 then
        if Ball_s[2] &lt;= -0.133 then
            C_K_B_X4()
        Y4_1 = Y4_1*3
        sim.setJointTargetVelocity(L4,Y4_1)
        elseif Ball_s[2] &gt; -0.133 then
            C_K_B_X4()
        Y4_2 = Y4_2*3
        sim.setJointTargetVelocity(L4,Y4_2)
        end
    end
--[[
    test_s = sim.getObjectPosition(test,-1)
    M =  test_s[2]- Ball_s[2]
    print(M)
--]]
    Body_s3 = sim.getObjectPosition(Body3,-1)
    X3_1 = Body_s3[1] - Ball_s[1]
    Y3_1 = Body_s3[2] - Ball_s[2]
    Y3_2 = Body_s3[2] - Ball_s[2] +0.2487
    Y3_3 = Body_s3[2] - Ball_s[2] -0.2487
    if X3_1 &gt;= 0.02 then
        if Ball_s[2] &lt; -0.0028 and Ball_s[2] &gt;= -0.2487 then
            C_K_B_X3()
        Y3_1 = Y3_1*1.5
        sim.setJointTargetVelocity(L3,Y3_1)
        elseif Ball_s[2] &gt;= -0.0028 then
            C_K_B_X3()
        Y3_2 = Y3_2*1.5
        sim.setJointTargetVelocity(L3,Y3_2)
        elseif Ball_s[2] &lt; -0.2487 then
            C_K_B_X3()
        Y3_3 = Y3_3*1.5
        sim.setJointTargetVelocity(L3,Y3_3)
        end
    end
end
function C_K_B_X2()
    if X2_1 &lt; 0.03 then
    sim.setJointTargetVelocity(LR2,-5)
    elseif X2_1 &gt; 0.03 then
    sim.setJointTargetVelocity(LR2,5)
    end
end
function C_K_B_X3()
    if X3_1 &lt; 0.03 then
    sim.setJointTargetVelocity(LR3,-5)
    elseif X3_1 &gt; 0.03 then
    sim.setJointTargetVelocity(LR3,5)
    end
end
function C_K_B_X4()
    if X4_1 &lt; 0.03 then
    sim.setJointTargetVelocity(LR4,-5)
    elseif X4_1 &gt; 0.03 then
    sim.setJointTargetVelocity(LR4,5)
    end
end</pre>
<p><iframe allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen="allowfullscreen" frameborder="0" height="315" src="//www.youtube.com/embed/nGLzb6gO8NI" width="560"></iframe></p>
<p>檔案:<a href="https://github.com/mdecadp2018/site-40623130/blob/gh-pages/v-rep/robot/ww5.ttt">https://github.com/mdecadp2018/site-40623130/blob/gh-pages/v-rep/robot/ww5.ttt</a></p>
<h4><span>回球判斷式-無軌道(包含計分判斷式)</span></h4>
<p>一開始還沒有導球軌道時，為了不用一直關掉在啟動，寫了一個簡單的回位code，讓球經過球門時，由於球門有判斷式屬於邊界，一通過就會回到設定好的球。</p>
<p>而計分也是利用相通的方法，且由於此程式會自動形成迴圈所以讓他判斷成每當球經過時+1分後回傳。此程式為最初簡易版本。</p>
<p><img alt="" height="564" src="./../images/FTB(7).gif" width="1000"/></p>
<p><span>以下都更改於function sysCall_actuation()中</span></p>
<div class="line number1 index0 alt2"><code class="lua spaces"><code class="lua spaces"><code class="lua spaces"> </code></code></code>
<pre class="brush:lua;auto-links:false;toolbar:false" contenteditable="false">       if 1 then  --C_goalkeeper
            if X &lt;= 0.02 then
                sim.setJointTargetVelocity(LR1,-5)
            elseif X &gt; 0.02 then
                sim.setJointTargetVelocity(LR1,5)
            end
       end
----------------
       if Ball_s[1] &lt; -0.85 or Ball_s[1] &gt;= 0.61 then
            sim.setObjectPosition(Ball,-1,{-0.1429, -0.1334, 0.5})
       end
</pre>
<code class="lua spaces"><code class="lua spaces"><br/></code></code><code class="lua spaces"><br/></code></div>
<p><iframe allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen="allowfullscreen" frameborder="0" height="315" src="//www.youtube.com/embed/nGLzb6gO8NI" width="560"></iframe></p>
<p><span></span>檔案:<a href="https://github.com/mdecadp2018/site-40623130/blob/gh-pages/v-rep/robot/Reborn.ttt">https://github.com/mdecadp2018/site-40623130/blob/gh-pages/v-rep/robot/Reborn.ttt</a></p>
<h4><span>偽-回球判斷式-有軌道</span></h4>
<p><span>也就是送球機構於上一章節的送球機構設計與模擬討論過</span></p>
<p><img alt="" height="564" src="./../images/FTB(14).gif" width="1000"/></p>
<pre class="brush:lua;auto-links:false;toolbar:false" contenteditable="false">function reborn_ball_count_goal()
    if Ball_s[1] &lt; -0.85 and Ball_s[3] &gt; 0.12507 then
        Player_G = Player_G + 1
--        sim.setObjectPosition(Ball,-1,{-0.13, -0.1334, 0.5})
    end   
    if Ball_s[1] &gt;= 0.61 and Ball_s[3] &gt; 0.1251 then
        Computer_G = Computer_G + 1
--        sim.setObjectPosition(Ball,-1,{-0.15, -0.1334, 0.5})
    end
    if Ball_s[3] &gt; 0.1251 then
        if Ball_s[1] &lt; -0.85 or Ball_s[1] &gt;= 0.61 then
            print[[Player : Computer]]
            print('      '..Computer_G..'     '..Player_G)
        end
    end
    if Ball_s[1] &gt; 0.905 and Ball_s[2] &lt; -0.069 and Ball_s[3] &lt; 0.036 then
        sim.setJointTargetVelocity(Push_1,1)
    end
    if Ball_s[1] &lt; -1.15 and Ball_s[2] &lt; -0.123 and Ball_s[3] &lt; 0.036 then
        sim.setJointTargetVelocity(Push_2,-1)
    end
    if Ball_s[3] &gt; 0.036 then
        sim.setJointTargetVelocity(Push_1,-1)
        sim.setJointTargetVelocity(Push_2,1)
    end
    if Ball_s[1] &lt; -1.156 and Ball_s[2] &gt; 0.163 and Ball_s[3] &gt; 0.058 then
    sim.setObjectPosition(Ball,-1,{-0.20361, 0.2739, 0.15735})
    end
    if Ball_s[1] &lt; -0.20361 and Ball_s[2] &gt; 0.2740 and Ball_s[3] &gt; 0.15735 then
    sim.setObjectPosition(Ball,-1,{-0.2049, 0.23, 0.1482})
    end
    if Ball_s[1] &gt; 0.9056 and Ball_s[2] &lt;  -0.4247 and Ball_s[3] &gt; 0.0592 then
    sim.setObjectPosition(Ball,-1,{-0.043425,  -0.60401, 0.15735})
    end
    if Ball_s[1] &gt; -0.04753 and Ball_s[2] &lt;  -0.5240 and Ball_s[3] &gt; 0.15735 then
    sim.setObjectPosition(Ball,-1,{-0.03667,  -0.48443, 0.1482})
    end
end</pre>
<p><span><iframe allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen="allowfullscreen" frameborder="0" height="315" src="//www.youtube.com/embed/HpKoChBwPaw" width="560"></iframe></span></p>
<p><span></span>檔案:<a href="https://github.com/mdecadp2018/site-40623130/blob/gh-pages/v-rep/robot/C_Goal_4.3.ttt">https://github.com/mdecadp2018/site-40623130/blob/gh-pages/v-rep/robot/C_Goal_4.3.ttt</a></p>
<h4>問題與討論</h4>
<p>Q1.怎麼沒有雙打?</p>
<p>A1.按鍵過多不好操控，最後會變成賽外賽?</p>
<p>Q2.彈性係數怎麼調整?</p>
<p>A2.<span>彈性系數於球的材質中調整，而材質的調整在關係設定的下方，表中的Restitution就是了最大彈性為1最小為0，越大越彈。</span></p>
<p><img src="./../images/FTB_attention%20(1).png"/></p>
<p>T3:<span>反作用設定:包含場地、球、桿件、人形 ((解釋起來很麻煩但大概是這樣</span></p>
<p><span>第一個為場地 : 第一行設定讓除了球、人形的桿件能反應但設定第八行讓球、人形可反應但桿件無法，其餘不勾選</span></p>
<p><img src="./../images/FTB_attention%20(5).png"/></p>
<p><span>第二個為球 : 第一行不勾選讓桿件與人行無法反應，但勾選其他行(第八)讓人形能反應</span></p>
<p><img src="./../images/FTB_attention%20(6).png"/></p>
<p>第三個為桿件 : 只與場地反應((這裡注意，桿件本身與人型成父子屬性</p>
<p><img src="./../images/FTB_attention%20(7).png"/></p>
<p>最後是人形 : 勾選第八行讓球反應可踢球且因與場地反應所以不出場地</p>
<p><img src="./../images/FTB_attention%20(8).png"/></p>
<p>理解這個需要一點邏輯...如果不懂就照勾選吧...</p>
<p>T4.<span>運行時建議 先點一下烏龜 太快會增加電腦能力也有機率bug</span></p>
<p><img src="./../images/FTB_attention%20(13).png"/></p><br />送球機構設計與模擬 << <a href='送球機構設計與模擬.html'>Previous</a> <a href='結案報告.html'>Next</a> >> 結案報告</div></section></div></body></html>